<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>A Pelican Blog</title><link href="/" rel="alternate"></link><link href="/feeds/chris-daley.atom.xml" rel="self"></link><id>/</id><updated>2016-01-08T10:50:00+00:00</updated><entry><title>Towards a Test Driven Development Framework in Vala Part 1.</title><link href="/test-driven-development-in-vala-pt-1.html" rel="alternate"></link><updated>2016-01-08T10:50:00+00:00</updated><author><name>Chris Daley</name></author><id>tag:,2016-01-08:test-driven-development-in-vala-pt-1.html</id><summary type="html">&lt;p&gt;I first came across &lt;a href="https://wiki.gnome.org/Projects/Vala"&gt;Vala&lt;/a&gt; when scoping out the possibility of updating a venerable old Open Source program from GTK+2 to GTK+3. I wasn't quite sure what to make of Vala at first - it was an Object Oriented Programming language based on the GObject type system that used C as an intermediary language for the gcc compiler. I looked through a bunch of the samples, and was struck by the elegance and parsimony of the syntax and how instantly understandable it was from my familiarity with Java and C#. I played with a few example apps and I was surprised at how much fun it was to use as well. It was GObject without the endless reams of boilerplate code. Properties actually made sense now and using signals is a snap. IDE support was about as good as any other language, especially in Geany, my tool of choice. I was hooked.&lt;/p&gt;
&lt;p&gt;There was only one problem. I'm a big fan of &lt;a href="https://en.wikipedia.org/wiki/Test-driven_development"&gt;TDD&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Behavior-driven_development"&gt;BDD&lt;/a&gt; and after many hours of intense Google-Fu, I was able to find precious little on the topic in regards to Vala. What &lt;a href="https://esite.ch/2012/06/writing-tests-for-vala/"&gt;there was&lt;/a&gt; boiled down to using the GLib Test library and a nice little adapter class to group individual test cases into a test suite. The end result was run through &lt;code&gt;gtester&lt;/code&gt; on the command line, usually as part of a toolchain like Autotools. This was straightforward enough for simple applications with limited user interactions, but it doesn't really scale for BDD. Some work had been done on a framework called &lt;a href="https://github.com/yorba/valadate"&gt;Valadate&lt;/a&gt; but it was abandoned by its maintainers a few years ago. This was a real blocker for me going forward. My philosophy is that you can occasionally write great software in moments of furious creativity but it takes boring old testing to consistently produce good software. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Feel the hate flow throw you" src="/images/unit-tests-dv.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;The thing with Free and Open Source Software is that it's only free at the cashier. Once you get it home you have to pay an ongoing maintenance cost in time if you want to keep using it. That time could be spent making minor contributions like filing bug reports through to helping new users in forums or translating apps all the way to implementing features yourself. I see real potential in Vala but I feel that it's usability is being hampered by this missing feature. The developers of the language have given the world a great gift and their time is better spent maintaining it. The current solution is &lt;em&gt;mostly&lt;/em&gt; good enough, but generates a lot of extra code to be maintained and has no support for BDD. "Somebody should do something about it" is a phrase that makes me groan whenever I hear it, because I usually think that that someone should be the person saying it. Well, someone should do something about it.&lt;/p&gt;
&lt;p&gt;So this blog post is an effort to get the ball rolling on that something. Although I have some free time now, it's not an endless wellspring. I also don't want to start a vaporware or abandonedware project that gets added to the list of good ideas people had at one point in time. I would like to build something that is sustainable, that evolves with its users and that could be easily passed on to other maintainers should I no longer have enough time to devote to it. I imagine this has been the manifesto of a thousand failed Open Source projects, but it's better than nothing, so here goes...&lt;/p&gt;
&lt;h3&gt;Getting the ball rolling&lt;/h3&gt;
&lt;p&gt;Since this a project to bring TDD and BDD to Vala, I would like to use Agile techniques to plan and develop it. The first steps in this case are setting up a Product Vision and Requirements Gathering. I'll take a stab at the first one (quoted because VISION STATEMENT).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For Vala developers who need to test their code, &amp;lt; insert cool tool name &amp;gt; is a powerful testing framework that provides behavioral, functional and unit testing features to help them write great Open Source software. Unlike other testing frameworks, &amp;lt; insert cool tool name &amp;gt; is designed especially for Vala while integrating seamlessly into existing toolchains.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I guess that makes me the Product Owner as well. I don't really care what it's called, Valadate is as good as any but I'm open to suggestions. If there are enough ideas we might have a poll.&lt;/p&gt;
&lt;p&gt;The next step will be the Requirements Gathering, one I have a number of ideas about already but I would really like to hear from the potential end users. I've started a Trello Board to that effect and if you would like to suggest a feature or comment on one that's already there, &lt;a href="http://bit.ly/1ZSrRA6"&gt;head on over&lt;/a&gt; and make yourself heard. If that's not your medium, you can ping me on &lt;a href="http://twitter.com/chebizarro"&gt;Twitter&lt;/a&gt; or hit me up on the Vala IRC channel (irc.gimp.org #vala), as &lt;code&gt;bizarro&lt;/code&gt;. A tool like this will live or die on its fitness for purpose, so please don't hold back.&lt;/p&gt;
&lt;p&gt;That's all for now, in the next post I'll summarize the requirements that have been gathered so far and lay out the options for the system architecture as well as a provisional schedule for the first release. Thanks for tuning in and don't forget to join the conversation if you have something to add.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>An easier way to write Python plugins for Dia</title><link href="/easy-python-for-dia.html" rel="alternate"></link><updated>2016-01-07T10:00:00+00:00</updated><author><name>Chris Daley</name></author><id>tag:,2016-01-07:easy-python-for-dia.html</id><summary type="html">&lt;p&gt;&lt;a href="https://wiki.gnome.org/action/show/Apps/Dia"&gt;Dia&lt;/a&gt; is a free and open source diagram creation program that runs on the main dekstop platforms. It's getting a bit long in the tooth, but its still a great tool. It's very easy to extend with plugins written in Python to add new features but the actual process of writing those plugins is a little bit more complicated.&lt;/p&gt;
&lt;p&gt;Firstly, the Python API is hard to find &lt;a href="https://projects-old.gnome.org/dia/pydia.html"&gt;online&lt;/a&gt;. You can generate a diagram of the API from within Dia itself from the Help menu, but this doesn't give you a whole lot of information and the format is a little incovenient. The API can be a little tricky to navigate, and I'll share some tips on that in a later post, but the biggest problem lies in testing the plugins that you write. Dia loads all of its plugins at startup and they can't be modified during runtime which makes testing and debugging a laborious process. It's possible to write and test the parts of your plugin that don't depend on Dia separately but once you start interacting with the UI it all starts to get bogged down again.&lt;/p&gt;
&lt;p&gt;&lt;img alt="My what a big API you have!" src="/images/dia-python-api.png" /&gt;&lt;/p&gt;
&lt;p&gt;Frustrated by this and wanting to develop a plugin using Test Driven Development (TDD) techniques, I wrote a small Python module that mocks the Dia API. This way you can write and test the vast majority of your plugin without having to run Dia at all! There are some limitations - any interactions with the UI for example have to be done in Dia either manually or with an automation framework, and you can't generate usable diagrams from it. It should, however, reduce the amount of time and bugs it takes to get your plugin up and running. Don't forget to Open Source it and share it with the world!&lt;/p&gt;
&lt;p&gt;If this is something you might find useful, you can check it out &lt;a href="https://github.com/chebizarro/dia-test"&gt;here&lt;/a&gt;. I originally developed it to meet the needs of a particular project I was working on at the time so there are some parts that may not be fully implemented, but I'm happy to take bug reports and pull requests. &lt;/p&gt;
&lt;p&gt;Installation is easy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;python setup.py install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is no practical difference in how you write your code and any existing plugin can use the module without modification. When the plugin runs outside of Dia, it loads the mock module, when it is run inside Dia, it loads the real one.&lt;/p&gt;
&lt;p&gt;Now you're all set up to start writing plugins for Dia the easy way!&lt;/p&gt;</summary><category term="Dia"></category><category term="Python"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Gherkin for Vala</title><link href="/gherkin-for-vala.html" rel="alternate"></link><updated>2016-01-04T20:50:00+00:00</updated><author><name>Chris Daley</name></author><id>tag:,2016-01-04:gherkin-for-vala.html</id><summary type="html">&lt;p&gt;I've had some spare time recently to work on some pet projects and get them into a decent enough shape that they could be subjected to the withering gaze of the Panopticon. One in particular is a port of the Gherkin language to Vala. So what is Gherkin exactly and why should you care?&lt;/p&gt;
&lt;p&gt;From the &lt;a href="https://github.com/cucumber/cucumber/wiki/Gherkin"&gt;Gherkin wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gherkin is the language that &lt;a href="https://cucumber.io/"&gt;Cucumber&lt;/a&gt; understands. It is a Business Readable, Domain Specific Language that lets you describe software’s behaviour without detailing how that behaviour is implemented.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Gherkin is available for a host of languages and is tightly integrated into JUnit for example. Its syntax is pretty straightforward and designed to be intelligible by non-technical people:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  Feature: Some terse yet descriptive text of what is desired
  Textual description of the business value of this feature
  Business rules that govern the scope of the feature
   Any additional information that will make the feature easier to understand

   Scenario: Some determinable business situation
     Given some precondition
       And some other precondition
      When some action by the actor
       And some other action
       And yet another action
      Then some testable outcome is achieved
       And something else we can check happens too

   Scenario: A different situation
       ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Gherkin parser for Vala, which you can get &lt;a href="https://github.com/chebizarro/gherkin-vala"&gt;here&lt;/a&gt; reads in Feature files and builds a tree of elements that can then either be manipulated directly or output as JSON.&lt;/p&gt;
&lt;p&gt;The parser by itself is not tremendously useful, but is one of the building blocks for a comprehensive testing framework for Vala and by extension, GObject that I am presently scoping. If this is something you're interested in, and I assume it is since you've read this far, then I'd encourage you to join the conversation.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Welcome Gnome</title><link href="/welcome-gnome.html" rel="alternate"></link><updated>2016-01-01T20:50:00+00:00</updated><author><name>Chris Daley</name></author><id>tag:,2016-01-01:welcome-gnome.html</id><summary type="html">&lt;p&gt;I don't recall when the first time I ever used the Gnome Desktop was, but it must have been around the turn of the century. I had first used Linux in 1997 when I installed it on a Power Mac out of frustration with the severely underpowered Mac OS 7.5. That install didn't stick around, as the only useful program I could find was the Gimp and the X11 Desktop left a lot to be desired in terms of user friendliness. Moving on from one employer to another, I used a variety of Desktop Managers over the next couple of years whilst working as a GIS analyst and programmer. CDE was the default for our X Terminals, although I liked to fool around with the SGI Indy's IRIX, which looked like it might be going somewhere different in user interfaces. That, and the Indy was five times faster than anything else in the lab. My main desktop was still a Mac and I ended up buying one of the super slick Powerbook Lombards before I knew what it's name actually meant. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Jurassic Park Security System" src="/images/jurassic-system.png" title="Um, sudo get me out of here?" /&gt;&lt;/p&gt;
&lt;p&gt;It wouldn't be until I landed in non-profit land that I ended up using Linux and the Gnome Desktop on a daily basis. I found Gnome at the time to be wholly unremarkable, if not perfectly usable for the task at hand. It was kind of like a strange hybrid of the old Mac OS and Windows 95, with menus and icons all over the place, most of which didn't do anything like what you would expect them to do on either of it's step siblings. There was very little visual consistency and clearly no User Interface guidelines or at least any that were being adhered to it. It was anarchic, wild, chaotic and above all, free. I quickly discovered I could make the UI even more inscrutable by applying a seemingly endless supply of themes, the results of which sometimes rendered the interface almost unusable. After a day or so of wasting time this way, I settled on the default theme with a slightly more muted colour blue and got back to work, mostly using the terminal anyway...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Gnome cerca 2000AD" src="/images/gnome-2000.jpg" title="Not my actual Desktop - this one is far too uncluttered" /&gt;&lt;/p&gt;
&lt;p&gt;Time passed and I found myself in some very strange places, with very few computers and almost no internet. It was Windows 2000 all the way baby, and after a while I found myself begrudgingly respecting the stability of the Redmond born beast as it powered on through conditions that few OSs have or will ever have to face. A fierce invalid home from hot climes and in need of a personal computer, I dug out my old Powerbook and installed the version of OS X that had been released whilst I was away from the online world. It ran like a dog. I maxed out the RAM, put in a new HDD and it still screamed "REPLACE ME" everytime I started it up. Unfortunately, the modest amount of money I had made during dot.com 1.0 had been long spent and several years of service in the common good had reduced me to near poverty myself. Spending even more money on buying a new computer was out of the question. I asked one of the neckbeardsI knew and he suggested I try this new Desktop Linux Distro called Ubuntu that everyone was raving about it. With nothing to lose but my sanity I bit the bullet and downloaded the Ubuntu ISO image and after accidentally making a few coasters with my girlfriend's Windows XP machine, I was up and running.&lt;/p&gt;
&lt;p&gt;The first thing that struck me was how pleasant the Desktop was. The Ubuntu humanity theme was, and still is, a very well crafted visual experience. The Gnome Desktop itself was significantly less cluttered and distracting than I remembered. Rather than being a hodgepodge of the worst elements of the Big Two, it had &lt;em&gt;mostly&lt;/em&gt; synthesised the best of both worlds. Things worked as expected, for the most part, and if they didn't, that was because there was a different paradigm at work rather than a bug or unimplemented feature. What's more, I could finally use my Powerbook again without wanting to throw it out the window. The Gimp took some getting used to, but only because I had been a top Photoshop jock and the muscle memory for keyboard shortcuts takes time to retrain. There was some pain, to be sure - the Lombard was a PowerPC after all, and not all the packages were available as binaries. The Package Manager itself left a lot to be desired and on at least one occasion I was painfully reminded that with great power comes great responsibility as I watched the system literally melt away in front of my eyes as I had accidentally uninstalled the Desktop. Still, I was happy and totally hooked on Linux and Open Source, even if the Desktop experience was still pre-XP.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Gnome Ubuntu 2004" src="/images/ubuntu.jpg" title="And it was still better than anything on Windows or Mac at the time" /&gt;&lt;/p&gt;
&lt;p&gt;And then the schism happened. The Gnome developers decided it was time for a revolution instead of evolution and Canonical decided to go its own way with Unity. It was like your parents breaking up and your Mum's new boyfriend moving in a week later. Unity was weird and didn't seem to work properly and the same could be said of Gnome 3. I had customised my Desktop with Docky and had set up a bunch of silly effects that never failed to impress (most people just assumed it was a Mac at first, ironically enough) and that was all about to change when Unity became the default. The apocalypse never happened though, I quit my job and bought a Netbook which came with Ubuntu and Unity preinstalled. Suddenly this weird new UI made sense, given that a Netbook's screen "real estate" would only be called generous if it were a New York loft apartment. Within a few short iterations (I love 6 monthly releases) the candy coloured task bar could be hidden and a few more tweaks made it pass from being barely usable to bearable to barely noticed. &lt;/p&gt;
&lt;p&gt;By the time I was back working a normal sized computer, Unity had matured to the point where I didn't even give it a second thought. Thanks to the considerable amount of time and money poured into Ubuntu by Canonical, I had a stable, functional modern desktop that didn't get in the way. I would have stayed completely oblivious to the inanity of the Linux Desktop Wars if not for the occasional foray into various forums in search of solutions or drivers. I didn't care - what I had &lt;em&gt;worked for me&lt;/em&gt;(tm) and boy was it working. Tasks like analysing electoral data by postcode or the cycle of water flows in river catchments and producing high quality visual representations for the web or print. The sort of things that sound like the pitch for very expensive, specialised proprietary software, but available for free on my computer with a single command. This to me was the Linux Desktop that had been long promised - a toolchain of powerful applications accessible through an interface that made them easier to use, not harder. I was more interested in tweaking the precision of my models than any bling. After a few months I realised that my desktop background was still the default. I rarely saw it anyway and I had long ago disciplined myself to resist the siren call of the Desktop folder. Sitting there crunching a massive dataset using purely open source tools, some of which I had written myself, I sure didn't feel like a N00B.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Domo Ubuntu" src="/images/domo_ubuntu.png" title="どうも、こんにちは?" /&gt;&lt;/p&gt;
&lt;p&gt;I didn't give it another thought until I went freelance and bought myself a new laptop, the one I'm writing this on today. No matter what I did, I couldn't get the internal Bluetooth adapter to work, either in Windows or Linux. I had read on some forums that the particular chip worked under Mint, so I downloaded the Live CD and tried it out. I wasn't thrilled with the idea of having to switch my OS, and I figured I might be able to isolate what about the Mint configuration made the device work and replicate it on Ubuntu. I was under-whelmed to say the least, and couldn't fathom what all the fuss was about. As far as user interfaces go, my laptop came with Windows 7 installed on it already, why would I opt for an inferior knockoff? In any case, it didn't work - the situation, and configuration, was exactly the same. Finally figuring that the actual hardware itself must be faulty, I popped the case and lo and behold, it was faulty alright, in so far as it wasn't even there. Unlike Windows, Linux wasn't lying, there was no Bluetooth adapter at all. I rechecked all of the paperwork and ... it turns out my particular laptop was a regionally specific model that came without the combination Bluetooth/WiFi that everybody else in the world got. D'oh. Oh well, good to know, especially since that meant I didn't have to install Mint just to be able to use my new Bluetooth headphoes.  &lt;/p&gt;
&lt;p&gt;And so it was for many, many moons. Ubuntu and Unity got progressively more stable and continued to perform almost flawlessly in a mission critical production environment - one where actual lives really were at stake. The interface shone by not shining, by being there when it was needed and not when it wasn't. I was at one with my desktop. Om. Then a serpent entered the garden, it started with a little personal project that would potentially run on Gnome as well as other desktops. In the spirit of best practice, I installed the Ubuntu Gnome Desktop package to see how my app would run under this much maligned interface. I was wary, having read a lot about how the over simplification of the Gnome shell had rendered it unusable for many, that it would be difficult to do common tasks that had once been easy and I would have to install a bunch of third party extensions to be able to get anything done. I was set up for a quick get in, get the screenshot and get out. I nervously logged in, not sure at all what to expect.&lt;/p&gt;
&lt;p&gt;The immediate thing that struck me was the freshness of the interface. Everything moved with a fluidity that was pleasing to the eye. The applications I needed to use were at most two clicks away, and when launched they took over the interface, becoming the sole focus. It took almost no time to figure out this brave new world, especially when things like multiple monitors worked right out of the box. I felt more productive immediately - this was not what I was expecting at all! The naysayers in many of the forums I had visited had clearly written it off at the beta stage, perhaps a little hastily, as it appeared to have blossomed from an ugly duckling into a beautiful, black swan. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Gnome 3 Desktop" src="/images/gnome3.png" title="A thing of beauty" /&gt;&lt;/p&gt;
&lt;p&gt;Much of the criticism levelled at Gnome 3 and Unity when they first appeared was that they were too strongly focused on emulating the touch driven interfaces of Android and iOS devices. A great deal was made of the assertion that what works on one platform doesn't translate to another and that the Desktop and the Handheld were fundamentally separate and irreconcilable paradigms. This may have been the case in 2009, but the present is a foreign country from the past, one where they do things differently. If I needed any convincing that this much heralded convergence of the handheld and desktop platform was more than hype, it was when my wife brought home her first Microsoft Surface. There it was, in one sweet, flyweight package, a full powered computer with a super responsive touchscreen. Sure, others had tried before, but M$ have really nailed it with this one. It's no surprise it's the cornerstone of their future hardware strategy and viewed in this light, the Windows 8.0 fiasco looks more ill timed than ill conceived. It's little wonder that Apple have been holding off on merging the Mac OS X and iOS platforms, especially since they don't seem to have a Surface killer lurking in the wings.&lt;/p&gt;
&lt;p&gt;For me, it's a bit of tragedy that this should have happened to the Linux Desktop as well. The user base was and is always going to be small - but that's OK. Despite what it might seem at any Linux conference these days, Mac OS X is not ubiquitous in the wild. Since it saved the Mac as a personal computer platform from obscurity in 2001, it has only increased its market share by some 6-7% and it's extremely unlikely that it will grow any further. Being a "niche" OS hasn't hurt Mac OS X one bit, nor has its deliberate lack of theming features - another complaint often levelled against Gnome. If the Linux Desktop is going to be niche though, it should be in the vanguard, not the fringe. The original, not the cheap knockoff.&lt;/p&gt;
&lt;p&gt;In any case, I'm sold. I now run Gnome exclusively on my Ubuntu laptop and have installed Fedora 23 on a recycled desktop with a new 24" multitouch monitor. I have started to rethink what the Linux User Experience should be and what as I a developer can contribute to that. Above all, Gnome 3 has shown me that using Linux on the desktop can be fun again. &lt;/p&gt;
&lt;p&gt;Welcome Gnome, it's nice to have you back.&lt;/p&gt;</summary><category term="Gnome"></category><category term="Open Source"></category><category term="Linux"></category><category term="Desktop"></category><category term="Ubuntu"></category></entry></feed>