<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>A Pelican Blog</title><link href="/" rel="alternate"></link><link href="/feeds/vala.atom.xml" rel="self"></link><id>/</id><updated>2016-01-08T10:50:00+00:00</updated><entry><title>Towards a Test Driven Development Framework in Vala Part 1.</title><link href="/test-driven-development-in-vala-pt-1.html" rel="alternate"></link><updated>2016-01-08T10:50:00+00:00</updated><author><name>Chris Daley</name></author><id>tag:,2016-01-08:test-driven-development-in-vala-pt-1.html</id><summary type="html">&lt;p&gt;I first came across &lt;a href="https://wiki.gnome.org/Projects/Vala"&gt;Vala&lt;/a&gt; when scoping out the possibility of updating a venerable old Open Source program from GTK+2 to GTK+3. I wasn't quite sure what to make of Vala at first - it was an Object Oriented Programming language based on the GObject type system that used C as an intermediary language for the gcc compiler. I looked through a bunch of the samples, and was struck by the elegance and parsimony of the syntax and how instantly understandable it was from my familiarity with Java and C#. I played with a few example apps and I was surprised at how much fun it was to use as well. It was GObject without the endless reams of boilerplate code. Properties actually made sense now and using signals is a snap. IDE support was about as good as any other language, especially in Geany, my tool of choice. I was hooked.&lt;/p&gt;
&lt;p&gt;There was only one problem. I'm a big fan of &lt;a href="https://en.wikipedia.org/wiki/Test-driven_development"&gt;TDD&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Behavior-driven_development"&gt;BDD&lt;/a&gt; and after many hours of intense Google-Fu, I was able to find precious little on the topic in regards to Vala. What &lt;a href="https://esite.ch/2012/06/writing-tests-for-vala/"&gt;there was&lt;/a&gt; boiled down to using the GLib Test library and a nice little adapter class to group individual test cases into a test suite. The end result was run through &lt;code&gt;gtester&lt;/code&gt; on the command line, usually as part of a toolchain like Autotools. This was straightforward enough for simple applications with limited user interactions, but it doesn't really scale for BDD. Some work had been done on a framework called &lt;a href="https://github.com/yorba/valadate"&gt;Valadate&lt;/a&gt; but it was abandoned by its maintainers a few years ago. This was a real blocker for me going forward. My philosophy is that you can occasionally write great software in moments of furious creativity but it takes boring old testing to consistently produce good software. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Feel the hate flow throw you" src="/images/unit-tests-dv.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;The thing with Free and Open Source Software is that it's only free at the cashier. Once you get it home you have to pay an ongoing maintenance cost in time if you want to keep using it. That time could be spent making minor contributions like filing bug reports through to helping new users in forums or translating apps all the way to implementing features yourself. I see real potential in Vala but I feel that it's usability is being hampered by this missing feature. The developers of the language have given the world a great gift and their time is better spent maintaining it. The current solution is &lt;em&gt;mostly&lt;/em&gt; good enough, but generates a lot of extra code to be maintained and has no support for BDD. "Somebody should do something about it" is a phrase that makes me groan whenever I hear it, because I usually think that that someone should be the person saying it. Well, someone should do something about it.&lt;/p&gt;
&lt;p&gt;So this blog post is an effort to get the ball rolling on that something. Although I have some free time now, it's not an endless wellspring. I also don't want to start a vaporware or abandonedware project that gets added to the list of good ideas people had at one point in time. I would like to build something that is sustainable, that evolves with its users and that could be easily passed on to other maintainers should I no longer have enough time to devote to it. I imagine this has been the manifesto of a thousand failed Open Source projects, but it's better than nothing, so here goes...&lt;/p&gt;
&lt;h3&gt;Getting the ball rolling&lt;/h3&gt;
&lt;p&gt;Since this a project to bring TDD and BDD to Vala, I would like to use Agile techniques to plan and develop it. The first steps in this case are setting up a Product Vision and Requirements Gathering. I'll take a stab at the first one (quoted because VISION STATEMENT).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For Vala developers who need to test their code, &amp;lt; insert cool tool name &amp;gt; is a powerful testing framework that provides behavioral, functional and unit testing features to help them write great Open Source software. Unlike other testing frameworks, &amp;lt; insert cool tool name &amp;gt; is designed especially for Vala while integrating seamlessly into existing toolchains.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I guess that makes me the Product Owner as well. I don't really care what it's called, Valadate is as good as any but I'm open to suggestions. If there are enough ideas we might have a poll.&lt;/p&gt;
&lt;p&gt;The next step will be the Requirements Gathering, one I have a number of ideas about already but I would really like to hear from the potential end users. I've started a Trello Board to that effect and if you would like to suggest a feature or comment on one that's already there, &lt;a href="http://bit.ly/1ZSrRA6"&gt;head on over&lt;/a&gt; and make yourself heard. If that's not your medium, you can ping me on &lt;a href="http://twitter.com/chebizarro"&gt;Twitter&lt;/a&gt; or hit me up on the Vala IRC channel (irc.gimp.org #vala), as &lt;code&gt;bizarro&lt;/code&gt;. A tool like this will live or die on its fitness for purpose, so please don't hold back.&lt;/p&gt;
&lt;p&gt;That's all for now, in the next post I'll summarize the requirements that have been gathered so far and lay out the options for the system architecture as well as a provisional schedule for the first release. Thanks for tuning in and don't forget to join the conversation if you have something to add.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Gherkin for Vala</title><link href="/gherkin-for-vala.html" rel="alternate"></link><updated>2016-01-04T20:50:00+00:00</updated><author><name>Chris Daley</name></author><id>tag:,2016-01-04:gherkin-for-vala.html</id><summary type="html">&lt;p&gt;I've had some spare time recently to work on some pet projects and get them into a decent enough shape that they could be subjected to the withering gaze of the Panopticon. One in particular is a port of the Gherkin language to Vala. So what is Gherkin exactly and why should you care?&lt;/p&gt;
&lt;p&gt;From the &lt;a href="https://github.com/cucumber/cucumber/wiki/Gherkin"&gt;Gherkin wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gherkin is the language that &lt;a href="https://cucumber.io/"&gt;Cucumber&lt;/a&gt; understands. It is a Business Readable, Domain Specific Language that lets you describe softwareâ€™s behaviour without detailing how that behaviour is implemented.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Gherkin is available for a host of languages and is tightly integrated into JUnit for example. Its syntax is pretty straightforward and designed to be intelligible by non-technical people:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  Feature: Some terse yet descriptive text of what is desired
  Textual description of the business value of this feature
  Business rules that govern the scope of the feature
   Any additional information that will make the feature easier to understand

   Scenario: Some determinable business situation
     Given some precondition
       And some other precondition
      When some action by the actor
       And some other action
       And yet another action
      Then some testable outcome is achieved
       And something else we can check happens too

   Scenario: A different situation
       ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Gherkin parser for Vala, which you can get &lt;a href="https://github.com/chebizarro/gherkin-vala"&gt;here&lt;/a&gt; reads in Feature files and builds a tree of elements that can then either be manipulated directly or output as JSON.&lt;/p&gt;
&lt;p&gt;The parser by itself is not tremendously useful, but is one of the building blocks for a comprehensive testing framework for Vala and by extension, GObject that I am presently scoping. If this is something you're interested in, and I assume it is since you've read this far, then I'd encourage you to join the conversation.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry></feed>