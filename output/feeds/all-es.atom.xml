<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>A Pelican Blog</title><link href="/" rel="alternate"></link><link href="/feeds/all-es.atom.xml" rel="self"></link><id>/</id><updated>2016-01-08T10:50:00+00:00</updated><entry><title>Hacia un framework de desarrollo guiado por pruebas para Vala - primera parte</title><link href="/test-driven-development-in-vala-pt-1-es.html" rel="alternate"></link><updated>2016-01-08T10:50:00+00:00</updated><author><name>Chris Daley</name></author><id>tag:,2016-01-08:test-driven-development-in-vala-pt-1-es.html</id><summary type="html">&lt;p&gt;Encontre &lt;a href="https://wiki.gnome.org/Projects/Vala"&gt;Vala&lt;/a&gt; por la primera vez cuando estaba averiguando la posibilidad de portear un viejo programa de código abierto desde GTK + 2 a GTK + 3. Yo no estaba muy seguro de qué hacer con Vala en aquel momento - era un lenguaje de programación orientado a objetos basado en el sistema de objetos de GObject y utilizaba C como el lenguaje intermediario con el compilador de gcc. Después de leer un montón de muestras, me llamó la atención la elegancia y parsimonia de la sintaxis y cómo fue comprensible de inmediato por mi familiaridad con Java y C #. Jugué con algunas aplicaciones de ejemplo y me sorprendió tal divertido fue utilizarlo también. Era GObject sin las interminables resmas de código repetitivo. Propiedades ya tenía sentido y el uso de señales resultaba mojo de pavo. Fue soportado por los ambientes de desarrollo integrado (IDE) tal como cualquier otro lenguaje, especialmente por Geany, mi herramienta preferida. Me enganché.&lt;/p&gt;
&lt;p&gt;Había un problema solamente. Soy un gran fan de &lt;a href="https://es.wikipedia.org/wiki/Desarrollo_guiado_por_pruebas"&gt;desarrollo guiado por pruebas&lt;/a&gt; o TDD (por sus siglas en ingles)  y después de muchas horas de intensa Google-Fu, encontré muy poco sobre el tema en respecto al Vala. Lo que &lt;a href="https://esite.ch/2012/06/writing-tests-for-vala/"&gt;hubo&lt;/a&gt; fue básicamente utilizar las funciones de prueba de la biblioteca GLib y una pequeña clase adaptador para agrupar los casos de prueba particulares en un conjunto de pruebas. El resultado final se llevó a cabo a través de &lt;code&gt;gtester&lt;/code&gt; por la línea de comandos, en general como parte de una cadena de herramientas como Autotools. Esto bastaba para aplicaciones sencillas con interacciones limitadas con el usario, pero en realidad no escalar para Desarrollo guiado por comportamiento (BDD en ingles). Alguien había desarrollado un framework llamado &lt;a href="https://github.com/yorba/valadate"&gt;Valadate&lt;/a&gt; pero esto fue abandonada por sus mantenedores ya hace unos años. Esto fue una verdadera bloqueo para mí. La filosofía mía es que de vez en cuando se puede escribir gran software en los momentos de creatividad furiosos pero se precisan pruebas aburridas para producir buen software consistentemente.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Su falta de fe me resulta molesta" src="/images/unit-tests-dv.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;La trampa con el software libre es que solamente no cuesta nada en el cajero. Una vez que llegues a casa, tienes que pagar el costo de mantenimiento en tiempo si quieres seguir utilizándolo. Ese tiempo podría ser gastado en hacer contribuciones menores, como la presentación de informes de errores hasta dar ayudar a los nuevos usuarios en los foros o la traducción de aplicaciones hasta agregando y desarrollando funciones. Yo veo mucha potencia en Vala pero siento que esta falta le debilita. Los desarrolladores del lenguaje han dado un gran regalo al mundo y su tiempo seria mejor gastado en mantenerlo. La solución que aun existe es &lt;em&gt;casi&lt;/em&gt; suficiente, pero genera una gran cantidad de código para mantener y no tiene soporte para BDD. "Alguien debería hacer algo" es una frase que me molesta mucho al escuchar, porque creo que ese alguien debería ser la persona que la dijo. Bueno, alguien debería hacer algo...&lt;/p&gt;
&lt;p&gt;Así que esta entrada del blog es un esfuerzo para tomar la iniciativa. Aunque en este momento tengo un poquito de tiempo libre, eso no var a ser el caso por siempre. Asimismo, no quiero empezar un proyecto vaporware o abandonadoware que seria agregado a la lista de buenas ideas que alguien tenía. Me gustaría construir algo que sea sostenible, que evolucione con sus usuarios y que podrían ser traspasado a otros mantenedores si ya no tenga tiempo suficiente para dedicarme an ello. Me imagino que esto ha sido el manifiesto de miles de proyectos de código abierto fallados, pero es mejor que nada - así que hay va ...&lt;/p&gt;
&lt;h3&gt;Tomar la iniciativa&lt;/h3&gt;
&lt;p&gt;Dado que el objetivo es capacitar Vala con TDD y BDD, me gustaría utilizar las técnicas de Agile para planificar y desarrollarlo. En este caso, los primeros pasos serian la creación de una visión de producto y la recopilación de requisitos. Voy a tomar el primer paso (citado porque VISIÓN DE PRODUCTO).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Para los desarrolladores de Vala que necesitan probar su código, &amp;lt; insertar el chulo nombre de herramienta &amp;gt; es un framework de pruebas de gran potencia que proporciona funciones de pruebas de las características de comportamiento, funcionales y  unitarias para ayudarles a escribir gran software de código abierto. La diferencia con los otros frameworks de prueba y &amp;lt; insertar el chulo nombre de herramienta &amp;gt; es que está diseñado especialmente para Vala, y integra perfectamente en las cadenas de herramientas ya existentes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Supongo me toca a mi ser el propietario del producto también. De veras, no me importa cómo sera llamado - Valadate es suficiente bueno tal como cualquiera, pero estoy abierto a sugerencias. Si hay suficientes ideas siempre podemos tener una encuesta.&lt;/p&gt;
&lt;p&gt;El siguiente paso será la recopilación de requisitos, lo que ya tengo algunas ideas, pero me gustaría saber lo que los usuarios potenciales piensan. Por eso he armado una pizarra Trello y si deseas sugerir una función o comentar sobre una que ya existe, &lt;a href="http://bit.ly/1ZSrRA6"&gt;haz clik aquí&lt;/a&gt; y hazte oír. Si eso no es su medio preferido, me puedes pingear en &lt;a href="http://twitter.com/chebizarro"&gt;Twitter&lt;/a&gt; o llamame en el canal de IRC de Vala (irc.gimp.org #vala), apodo: &lt;code&gt;bizarro&lt;/code&gt;. Una herramienta como esta va a vivir o morir debido a su aptitud para el uso, así que no te callas por favor!&lt;/p&gt;
&lt;p&gt;Ya esta, en el próximo post voy a resumir los requisitos que aun se han ajuntado y poner a la mesa las opciones para la arquitectura del sistema además de un calendario provisional para la primera versión. Gracias por escuchar y no olvides de unirse a la conversación si tiene algo que decir.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Código Abierto"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>La manera más fácil de escribir complementos para Dia en Python.</title><link href="/easy-python-for-dia-es.html" rel="alternate"></link><updated>2016-01-07T10:00:00+00:00</updated><author><name>Chris Daley</name></author><id>tag:,2016-01-07:easy-python-for-dia-es.html</id><summary type="html">&lt;p&gt;&lt;a href="https://wiki.gnome.org/action/show/Apps/Dia"&gt;Dia&lt;/a&gt; es software libre para la creación de diagramas libre y es multiplataforma. Ya está un poquito viejo, pero siga siendo una gran herramienta. Es muy fácil agregarle funciones nuevas con complementos (plugins) desarrollados en Python pero el proceso mismo de escribir esos complementos es un poco más complicado.&lt;/p&gt;
&lt;p&gt;En primero, la interfaz de programación de aplicaciones (API) de Dia para Python es difícil de encontrar en  &lt;a href="https://projects-old.gnome.org/dia/pydia.html"&gt;línea&lt;/a&gt;. Siempre puedes generar un diagrama de la API desde adentro de Dia mismo pero ese no te daría mucha información y el formato es un poco inconveniente. La API puede ser un poquito difícil de navegar y voy a compartir algunos trucos sobre ese tema en un post más adelante pero el problema más grande se yace en probando los complementos que escribes. Dia carga todos los complementos al inicio y no se pueden modificar durante la ejecución del programa, así que el proceso de probar y depurar resulta laborioso. Es posible escribir y probar las piezas de tu complemento que no dependen en Dia aparte pero una vez que comiences la interacción con la interfaz, se atasca de nuevo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Vaya API grande!" src="/images/dia-python-api.png" /&gt;&lt;/p&gt;
&lt;p&gt;Frustrado por eso y deseando desarrollar un complemento siguiendo las técnicas de desarrollo guiado por pruebas (TDD), escribí un pequeño modulo de Python que simular la API de Dia. Así que puedes escribir y probar la gran mayoría de tu complemento sin tener que ejecutar Dia en absoluto! Hay limitaciones - por ejemplo cualquiera interacción con la interfaz tiene que ser hecho dentro de Dia, o a mano o con un automation framework y no se puede generar diagramas útiles. Sin embargo, debería reducir la cantidad de tiempo y bugs que cueste poner en marcha tu complemento. No olvides de darle una licencia de software libre y compartirlo con el mundo! &lt;/p&gt;
&lt;p&gt;Si eso es algo que te serviría, puedes darle un vistazo &lt;a href="https://github.com/chebizarro/dia-test"&gt;ahi&lt;/a&gt;. Originalmente, lo desarrolle para satisfacer las necesidades de un proyecto determinado en lo que estaba trabajando asi que hay unas partes que no están completas pero estoy dispuesto de tomar avisos de bugs y pull requests. &lt;/p&gt;
&lt;p&gt;Es fácil instalar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;python setup.py install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;No hay ninguna diferencia en la manera de escribir tu código y cualquier complemento existente puede usar el modulo sin ser modificado. Cuando el complemento se ejecuta fuera de Dia, se carga el modulo de simulación, cuando se ejecuta dentro de Dia, se carga lo verdadero.&lt;/p&gt;
&lt;p&gt;Ya estas listo para empezar de escribir complementos para Dia en la manera mas fácil!&lt;/p&gt;</summary><category term="Dia"></category><category term="Python"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category><category term="Software Libre"></category></entry></feed>