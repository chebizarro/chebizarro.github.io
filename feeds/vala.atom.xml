<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Enter the Panopticon</title><link href="http://chrisdaley.biz/" rel="alternate"></link><link href="http://chrisdaley.biz/feeds/vala.atom.xml" rel="self"></link><id>http://chrisdaley.biz/</id><updated>2016-02-20T10:00:00-08:00</updated><entry><title>Towards a Test Driven Development Framework in Vala Part 5 - Minimum Viable Product</title><link href="http://chrisdaley.biz/test-driven-development-in-vala-pt-5.html" rel="alternate"></link><updated>2016-02-20T10:00:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-02-20:test-driven-development-in-vala-pt-5.html</id><summary type="html">&lt;p&gt;Things have really been moving quickly since I last posted, with the development branch really starting to take shape. When I sat down to look at the list of requirements, I decided that the best place to start for a first release would be to at least replicate the same feature set of the original. To recap, those were:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Automatic test discovery like JUnit or .NET testing framework.&lt;/li&gt;
&lt;li&gt;Running tests for all parameters from specific set.&lt;/li&gt;
&lt;li&gt;Utility functions for waiting in a main loop until specified event or
    timeout occurs.&lt;/li&gt;
&lt;li&gt;Support for asynchronous tests. Method declared async in vala will be
    automatically run under main loop until completion or configurable
    timeout.&lt;/li&gt;
&lt;li&gt;Utility functions providing temporary directory to tests.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These have been translated into GitHub &lt;a href="https://github.com/chebizarro/valadate/issues"&gt;issues&lt;/a&gt; and the Waffle &lt;a href="https://waffle.io/chebizarro/valadate"&gt;board&lt;/a&gt; as well as a few additional features that I thought should make the first cut, namely:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/chebizarro/valadate/issues/6"&gt;Geanie support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/chebizarro/valadate/issues/1"&gt;Working examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These have all been added to the Version 1.0.0 &lt;a href="https://github.com/chebizarro/valadate/milestones/Version%201.0.0"&gt;milestone&lt;/a&gt; and
well, I'm pleased to say that after a little under two weeks of concerted effort, I have (re)implemented almost all of the above features! Based on the level of effort so far, I am now envisaging an initial release as early as the 1st of March.&lt;/p&gt;
&lt;p&gt;I'm actually pretty excited about what has come out of the process so far. One of the original itches I set out to scratch was the verbosity of unit tests in Vala and through the voodoo of xml/xslt/json and GModule I believe I have achieved that. While the implementation details are frankly a little scary, the resulting user facing API hides them quite nicely.&lt;/p&gt;
&lt;p&gt;With a correctly configured build script, using Valadate is as easy as declaring a subclass of &lt;code&gt;TestCase&lt;/code&gt; and adding annotated instance methods like so: &lt;/p&gt;
&lt;script src="http://gist-it.appspot.com/https://github.com/chebizarro/valadate/blob/version-1.0.0/tests/libvaladate/data/testexetwo.vala?slice=18:"&gt;&lt;/script&gt;

&lt;p&gt;That's it. No &lt;code&gt;main&lt;/code&gt; function required, no need to add tests in the &lt;code&gt;TestCase&lt;/code&gt; constructor. Clean and simple, the way it should be. The code snippet above is a real live test from the Valadate framework (the actual test of the test, so to speak) and it runs beautifully, producing TAP output both to file and to the terminal -&lt;/p&gt;
&lt;p&gt;&lt;img alt="Love that green!" src="http://chrisdaley.biz/images/terminal.png" /&gt;&lt;/p&gt;
&lt;p&gt;Astute readers will notice that it is still GLib.Test running things under the hood, although it is sufficiently encapsulated to allow its gradual replacement without affecting the way end users write their tests. It should now be possible to add things like events and notifications without breaking user's code.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;TestRunner&lt;/code&gt; class handles test discovery via a Gir file output when the test is compiled. This was a key concept of the original Valadate but I took it a step further, combining it with GModule to create a kind of "poor person's" Introspection module. The test binary needs to be compiled as a Position Independent Executable (PIE) for this to work which is presently only supported on Linux and Mac OSX, although the fundamentals should apply to executable DLLs on Windows as well. &lt;/p&gt;
&lt;p&gt;The &lt;code&gt;TestRunner&lt;/code&gt; currently supports &lt;code&gt;[Test], [AsyncTest]&lt;/code&gt; and &lt;code&gt;[SkipTest]&lt;/code&gt; with parameters. Although it is trivial to add new annotations, I am going to keep them to a minimum and move to a plugin based model which will allow plugins to decorate and control how test methods are run.&lt;/p&gt;
&lt;p&gt;Of course, if all of this is a little too funky for you, you can still do things the old way by adding each test method in the TestCase's constructor:&lt;/p&gt;
&lt;script src="http://gist-it.appspot.com/https://github.com/chebizarro/valadate/blob/version-1.0.0/tests/libvaladate/utils/testsignalwaiter.vala?slice=42:47"&gt;&lt;/script&gt;

&lt;p&gt;and providing your own &lt;code&gt;main&lt;/code&gt; entry point like so:&lt;/p&gt;
&lt;script src="http://gist-it.appspot.com/https://github.com/chebizarro/valadate/blob/version-1.0.0/tests/libvaladate/utils/main.vala?slice=2:12"&gt;&lt;/script&gt;

&lt;p&gt;in this case, you don't need to compile it as a PIE binary or add the Method annotations (they won't work anyway). You can still use all of Valadate's other awesome features such as asynchronous tests, you'll just have more redundant code to manage.&lt;/p&gt;
&lt;p&gt;With this feature now implemented and on the way to being solidly tested, I feel it's time to merge the development branch and roll a release. That way I can start getting feedback (and bug reports) on what's been done so far before implementing the meatier features like Gherkin integration and a GUI.&lt;/p&gt;
&lt;p&gt;It goes without saying that the only way anybody will be able to use Valadate is if there is clear documentation and working examples, so to this end there are now several &lt;a href="https://github.com/chebizarro/valadate/tree/version-1.0.0/examples"&gt;example projects&lt;/a&gt; and a &lt;a href="https://github.com/chebizarro/valadate/wiki"&gt;Wiki&lt;/a&gt;. I've also added support for building Valadoc and GtkDoc docs from the project source tree. There's still a bit of work to do before the first release, but the infrastructure is now in place (and I can close &lt;a href="https://github.com/chebizarro/valadate/issues/1"&gt;issue #1&lt;/a&gt;!).&lt;/p&gt;
&lt;p&gt;So that's all I'm going to go into in this post, so I can get back to documenting the work I've done and getting the release ready for deployment. The next post on Valadate will be about the release, so now's a good a time as any to jump in and let me know what you think, in the comments below or in the "usual" places. Thanks for watching!&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category><category term="CoC"></category></entry><entry><title>Towards a Test Driven Development Framework in Vala Part 4. Who Tests the Tester?</title><link href="http://chrisdaley.biz/test-driven-development-in-vala-pt-4.html" rel="alternate"></link><updated>2016-02-04T16:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-02-04:test-driven-development-in-vala-pt-4.html</id><summary type="html">&lt;p&gt;After a short break to work on one of my other projects (&lt;a href="http://www.last.fm/music/Calisse"&gt;a Rock 'n Roll band&lt;/a&gt;) and finish setting up &lt;a href="http://jenkins.valadate.org:8080"&gt;Jenkins&lt;/a&gt;, I'm back at work on the project now officially known as &lt;a href="https://github.com/chebizarro/valadate"&gt;Valadate&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As I've mentioned before, there were some initial attempts at developing a TDD framework for Vala, the most extensive of them being &lt;a href="https://github.com/yorba/valadate"&gt;Valadate&lt;/a&gt;. After some consideration, and a review of the existing codebase, I decided that the most practical approach would be to assume maintainership of it and refactor/rewrite as necessary to meet the new requirements that have been &lt;a href="http://bit.ly/1ZSrRA6"&gt;gathered&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Presently, the existing Valadate package provides a number of utility classes for such things as asynchronous tests and temporary directories as well as a command line Test Runner. The procedure for writing tests is to create a concrete implementation of the Valadate Fixture interface with each unit test being a method whose name starts with &lt;code&gt;test_&lt;/code&gt;. The test is then compiled into a binary (shared library) which is run by the Test Runner. Test discovery is done by loading the .vapi and .gir files generated by Vala when the binary is compiled. The build system is &lt;a href="https://en.wikipedia.org/wiki/Waf"&gt;Waf&lt;/a&gt;, but for the purposes of reviewing the code, I ported it to autotools, a build system I am more comfortable with.&lt;/p&gt;
&lt;p&gt;The code compiles, but it has suffered from some bitrot, with quite a number of deprecation warnings, especially the asynchronous tests. The actual framework is quite lean and uses the GLib Test and TestSuite classes to group and run the tests it finds in the binary. In total there probably isn't more than 1000 SLOC in the whole project. While I see some interesting ideas in the current code, I have decided that the best approach is to start again from scratch and incorporate whatever is useful and send the remainder to binary heaven || hell.&lt;/p&gt;
&lt;p&gt;So now that I have the repository for Valadate setup and updated to build with autotools, I will use this as the &lt;code&gt;master&lt;/code&gt; from which we will derive the various development branches, using the widely practiced &lt;a href="https://guides.github.com/introduction/flow/"&gt;"GitHub Flow"&lt;/a&gt;, a repository management process which embodies the principles of Continuous Integration. In a nutshell, it involves six discrete steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a branch for developing a new feature&lt;/li&gt;
&lt;li&gt;Add commits to the branch&lt;/li&gt;
&lt;li&gt;Open pull requests&lt;/li&gt;
&lt;li&gt;Discuss and review the code&lt;/li&gt;
&lt;li&gt;Deploy&lt;/li&gt;
&lt;li&gt;Merge&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The underlying principle (or "one rule" as GitHub calls it) is that the &lt;code&gt;master&lt;/code&gt; branch is always deployable - which in the case of a tool like Valadate means it can be pulled, compiled and run at any time. So while the existing &lt;code&gt;master&lt;/code&gt; branch of Valadate is not exactly production ready, it is in the state where the Yorba Foundation stopped maintaining it. This at least gives us a baseline from which to start and some continuity with the original project, if only giving credit to the original developers for their hard work.&lt;/p&gt;
&lt;p&gt;We're ready to branch our new version, so what do we call it? The most commonly used system is &lt;a href="http://semver.org/spec/v2.0.0.html"&gt;Semantic Versioning&lt;/a&gt; which follows the MAJOR.MINOR.PATCH convention:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MAJOR version when you make incompatible API changes,&lt;/li&gt;
&lt;li&gt;MINOR version when you add functionality in a backwards-compatible manner, and&lt;/li&gt;
&lt;li&gt;PATCH version when you make backwards-compatible bug fixes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The last release of Valadate was 0.1.1 and it's not entirely clear if they were strictly following the Semantic Versioning scheme. There are separate API and SO version numbers which may not be applicable in our first release. So for simplicity, I will use the original version number as the starting point. As we are going to make some fairly substantial changes that would break the hell out of the 0 API, we should probably increment that to 1. Since we are starting from scratch, the MINOR version will revert to 0 as well. So the branch name that we will begin working on our new implementation under will be 1.0.0.&lt;/p&gt;
&lt;p&gt;Sweet. Let's dial up those digits:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git checkout -b version-1.0.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The local repository is now a new branch called &lt;code&gt;version-1.0.0&lt;/code&gt;, which will allow us to start really overhauling the code without affecting the "deployable" &lt;code&gt;master&lt;/code&gt; branch. Since we're going to break more things than a stoner in a bong shop, we may as well reorganise the file layout to something more conventional and dispose with the Waf build system altogether.&lt;/p&gt;
&lt;p&gt;Our new repository directory structure looks like this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;valadate&lt;ul&gt;
&lt;li&gt;libvaladate&lt;/li&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;li&gt;tests&lt;ul&gt;
&lt;li&gt;libvaladate&lt;/li&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This structure is a fairly commonly used pattern in developing medium to large size projects, you essentially replicate the source tree within the tests folder. This makes it easier to locate individual tests and means your integration tests will follow the same basic pattern as the main source tree does at compile time. With smaller projects, you could just get away with a simple &lt;code&gt;tests&lt;/code&gt; directory - with the relatively small SLOC that Valadate has now it could probably all reside within a single source file! Given that we expect the project to grow significantly though, especially when we start adding complex features like BDD tests and a GUI as well as several layers of tests of tests, we should probably start with a more scalable structure.&lt;/p&gt;
&lt;p&gt;OK, now we're finally ready to start writing tests. Given that this is a Testing Framework, we're facing a potential chicken and egg situation - what framework do we use to test our framework? In this case, the solution is pretty straightforward, we have the GLib Test suite at our disposal which we can use to write the base tests that will guide the design of the framework. Once these tests all pass, we can move on to using Valadate to test itself when adding more complex testing features like Gherkin/Cucumber. Finally, we can use those features for even more complex testing such as user acceptance and integration tests for the project as a whole. The process is iterative and cascading, meaning that as features at one level are sufficiently tested they will become available for the next successive layer of tests. You could think of it like an Onion, if you like, or a series of waterfalls but my mental image at the moment is more like this:&lt;/p&gt;
&lt;p&gt;
&lt;iframe allowfullscreen="true" frameborder="0" height="315" src="//www.youtube.com/embed/eMqGdRqj1_0" width="560"&gt;&lt;/iframe&gt;
&lt;/p&gt;
&lt;p&gt;But that's just me. Use whatever metaphor you like, it's your head after all.&lt;/p&gt;
&lt;p&gt;So we begin using the basic or 'naked' (as I like to call it) &lt;a href="https://developer.gnome.org/glib/stable/glib-Testing.html"&gt;GLib Testing Framework&lt;/a&gt;. Now the GLib Testing Framework is actually pretty powerful and was originally designed according to the xUnit interface. It's fairly straightforward to use, as this example from the &lt;a href="https://wiki.gnome.org/Projects/Vala/TestSample"&gt;Gnome Vala Wiki&lt;/a&gt; shows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;add_foo_tests&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/vala/test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ref&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;add_foo_tests&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It also has the gtester and gtester-report utilities which are well integrated with existing toolchains and are able to output test results in a variety of formats.&lt;/p&gt;
&lt;p&gt;The main drawbacks of the GLib Testing Framework, and hence the need for Valadate at all, are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is not particularly Object Oriented - the base classes are all &lt;code&gt;[Compact]&lt;/code&gt; classes and do not inherit from a common Test base class. This makes extending them in Vala difficult.&lt;/li&gt;
&lt;li&gt;The test report functions need a lot of configuration to produce usable output, including several 'drivers' or shell scripts for postprocessing.&lt;/li&gt;
&lt;li&gt;It is not particularly well documented&lt;/li&gt;
&lt;li&gt;It doesn't scale very well to large projects or for Behavior Driven Design.&lt;/li&gt;
&lt;li&gt;It's verbose and difficult to read.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most of these limitations are solvable in one form or another, so it should serve as a sufficient base to get started. If we follow the principles of Test Driven Design it should become obvious when we need to build something more powerful or flexible.&lt;/p&gt;
&lt;p&gt;Which tests and features do we write first? Well, that's determined by the requirements we've gathered and how we've prioritised them. One of the many great things of having a wife who is a CTO for a foundation developing open source land tenure software is that I get to vicariously experience how she manages her team's workflow and the tools they use to do that. One of the recent tools that they have started using for project management is &lt;a href="https://waffle.io/"&gt;Waffle&lt;/a&gt;, which integrates seamlessly with GitHub Issues and Pull Requests. Waffle is the next step beyond the &lt;a href="http://bit.ly/1ZSrRA6"&gt;Trello board&lt;/a&gt; that I was using to initially gather the requirements for Valadate. Waffle allows anyone to add a feature request or file a bug to the Backlog either through the &lt;a href="https://waffle.io/chebizarro/valadate"&gt;Waffle board&lt;/a&gt; for the project or by simply creating a &lt;a href="https://github.com/chebizarro/valadate/issues/new"&gt;new issue&lt;/a&gt; on the GitHub page. The latter is the most straightforward as you don't need to log into Waffle at all.&lt;/p&gt;
&lt;p&gt;One of my wife's philosophies of Open Source is that it's not enough to just release your source code. A true Open Source project is also developed in the open, meaning that the history behind why certain design decisions were made, and by who, is recorded and all issues and pull requests are reviewed and where they meet the project's (i.e. enduser's) requirements, are fixed or merged, regardless of the source. Public repositories are, at the very least mirrors if not the working versions of the current master and branches, not just static snapshots of a final release.&lt;/p&gt;
&lt;p&gt;Taking an Open from the Start approach is also something that is essential in building a strong, diverse community of users around your product. Sarah Sharp, a long time Linux Kernel contributer, has written extensively about this on her &lt;a href="http://sarah.thesharps.us/2015/10/06/what-makes-a-good-community/"&gt;blog&lt;/a&gt;. One of the things that I'm going to take the opportunity to lock down now is a Code of Conduct for contributors. I'm not going to go into the pros and cons of having a Code of Conduct - as I don't see any cons in the first place! So, as Sarah says on her blog -&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We don’t write legal agreements without expert help. We don’t write our own open source licenses. We don’t roll our own cryptography without expert advice. We shouldn’t roll our own Code of Conduct.&lt;a href="http://sarah.thesharps.us/2016/01/25/code-of-conducts-warning-signs/"&gt;1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With that in mind, I've signed the project on to the &lt;a href="http://todogroup.org/opencodeofconduct/#Valadate/chebizarro@gmail.com"&gt;Open Code of Conduct&lt;/a&gt;, which is used by GitHub and is inspired by the codes of conduct and diversity statements of projects like Django, Python and Ubuntu. It's worth a read, even if it's your bread and butter, but here's my summary - "don't be an asshat" - and you can tweet me on that.&lt;/p&gt;
&lt;p&gt;So that's all for this post, join me again soon for Part 5 where I will outline the product roadmap for the first release and delve into when we know we've tested enough with coverage reports. Thanks for reading and please feel free to join the conversation if you have something to say!&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category><category term="CoC"></category></entry><entry><title>Towards a Test Driven Development Framework in Vala Part 3. DevOps - Continuous Integration with Jenkins</title><link href="http://chrisdaley.biz/test-driven-development-in-vala-pt-3.html" rel="alternate"></link><updated>2016-01-19T10:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-19:test-driven-development-in-vala-pt-3.html</id><summary type="html">&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Continuous_integration"&gt;Continuous Integration&lt;/a&gt; or CI is widely used in Test Driven Design for keeping the project's codebase tight, reducing errors and making sure there is always a working build available for deployment. It provides a means to automate the whole build and testing process, so developers can focus on writing their tests and the code that passes them. By setting up a system that builds and tests the software on its supported platforms, deployment issues can be identified early and distribution of new releases automated.&lt;/p&gt;
&lt;p&gt;Since once of the objectives of Valadate is to integrate with existing toolchains, and wanting to leverage the numerous benefits of CI for the project itself, I took a short DevOps break to set up a &lt;a href="https://jenkins-ci.org/"&gt;Jenkins&lt;/a&gt; based system on my local network. Jenkins is a widely used open source Continuous Integration server written in Java, so it can pretty much run anywhere, providing the system has enough juice. Taking this to its extreme, I decided to install it on a spare Raspberry Pi 2 I had lying around. So why Jenkins and why on a Raspberry Pi?&lt;/p&gt;
&lt;p&gt;Firstly, Jenkins is a robust and well maintained platform that is widely used. It has a plethora of plugins that integrate it tightly with Git, Docker, TAP and numerous other CI tools and protocols. It works on the master-slave model, where the master server directs the build operations of any number of slaves. A slave can be any other computer on the network that Jenkins can communicate with, either directly through SSH or with a plugin. It is highly configurable and it just works. It seemed like a good choice to start with.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The Jenkins web interface" src="http://chrisdaley.biz/images/jenkins.png" /&gt;&lt;/p&gt;
&lt;p&gt;Secondly, the Raspberry Pi. One of my considerations when setting up the CI system was that the master server should be internet accessible and available 24-7. Given that when it isn't running jobs the server is mostly idle, using a full powered computer would be a waste of electricity and CO2. It occurred to me that one of my spare Rapsberry Pis could do the job, so after a quick Google to confirm that it was possible, I proceeded with the install. The one comprehensive guide I had found had suggested a lot mucking about with downloading source packages, but since it was for the previous version of Raspbian I tried &lt;em&gt;sudo apt-get install jenkins&lt;/em&gt; and whaddya know, it just worked.&lt;/p&gt;
&lt;p&gt;With the Jenkins server up and running, I added my recent &lt;a href="http://github.com/chebizarro/gherkin-vala"&gt;port of Gherkin&lt;/a&gt; as a test job and set up a machine running Fedora 23 as a slave and in 5 minutes it had checked out, compiled and run the unit tests on it and...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Build Status" src="http://chrisdaley.biz/images/passing.png" /&gt;&lt;/p&gt;
&lt;p&gt;\O/ \O/ \O/&lt;/p&gt;
&lt;p&gt;Despite being relatively low-powered, the Raspberry Pi seems up to the task, as nothing is actually being built on it. Some configuration pages take a while to load, but for ordinary usage it's quite snappy. Not only that, but you can do &lt;a href="https://www.perforce.com/blog/150910/continuous-delivery-fun-jenkins-raspberry-pi"&gt;cool things&lt;/a&gt; with it as well. &lt;/p&gt;
&lt;p&gt;Emboldened by my initial success, I moved onto setting up a Docker slave. For this setup, I revived an old server that had been mothballed, with the idea that as a build slave it doesn't need to be online all the time and with Wake On Lan (WOL) I can have Jenkins wake the server up when it needs to do a build and put it back to sleep when its done. This is still on the to-do list, but seems fairly straightforward.&lt;/p&gt;
&lt;p&gt;In this configuration, the slave is a Docker host that starts up and runs a container built from a Dockerfile in the repositories root. It is this container that runs the build, not the host, so it is possible to test your software on pretty much any platform that can be dockerized. Cool eh? So I set up an Ubuntu container and...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Build Status" src="http://chrisdaley.biz/images/failing.png" /&gt;&lt;/p&gt;
&lt;p&gt;Huh?!? I looked at the log and...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;./.libs/libgherkin3.so: undefined reference to `g_value_init_from_instance&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dammit! In my rush to port Gherkin, I had done it on my new Fedora 23 box and hadn't actually tested it on Ubuntu at all. I checked the docs and sure enough, GLib.Value.init_from_instance() is available from GLib 2.42 on only and Ubuntu 15.04 ships with 2.40. D'oh! So now I either have to refactor the code or declare GLib 2.42 a prerequisite.&lt;/p&gt;
&lt;p&gt;This particular case is a really good example of the benefits of Continuous Integration. If I had had the Jenkins server set up before I ported the code, I would have noticed the incompatibility almost immediately and would have been able to deal with it then, rather than refactoring later.&lt;/p&gt;
&lt;p&gt;As nice as it would be to ignore the existence of other operating systems, the sad truth is that not everyone uses Linux as their primary desktop, including many people who might want to use my software. With this harsh reality in mind, I decided to set up Windows and Mac OSX slaves to test the cross platform compatibility of my projects.&lt;/p&gt;
&lt;p&gt;For the Windows slave, I set up a new Windows 7 VM in VirtualBox, running on the same server as the Docker host. For the build toolchain, I installed MinGW64 and MSYS2 and all of the necessary libraries and voila! Well, not quite voila, the MinGW linker is soooo sloooow that it took quite some time to debug but is now working just fine. The process isn't quite fully automated - I still need to manually spin it up and shut it down. There is a VirtualBox plugin to do this, but it doesn't presently support version 5. I also learned the hard way that you need to disable automatic updating for Windows, otherwise it will get stuck at the failed boot recovery screen. I am also thinking that for speed, I will cross compile the Windows binaries in a Docker container and run the tests in the Windows VM to make sure they work.&lt;/p&gt;
&lt;p&gt;Now, if you've been to any major Linux conference in the last few years, you'd be forgiven for thinking you were at WWDC with all the Apple hardware being toted about. Heck, my wife, an Open Source guru, was a long time MacBook Air user until she got a Microsoft Surface. And it's true, it is some of the coolest, most expensive hardware you can run a Linux Virtual Machine on. Don't get me wrong, I have one on my desk, I just mostly use it for email, IRC and the occasional Photoshop session (at least until Gimp gets better tablet support). Unfortunately, it's been a little neglected so it needs a bit of a clean up before it can be pressed into service, which will hopefully be by the start of next week.&lt;/p&gt;
&lt;p&gt;Along the way I also discovered that our crappy Comcast provided Cable Modem doesn't support hairpin DNS resolutions when I forwarded the Jenkins server ports. I tried to solve this by setting up dnsmasq on the Raspberry Pi but it still required manually editing the resolv.conf files on each machine. In the end I just put the Comcast Modem into bridge mode and set up a trusty old WRT-54GL running DD-WRT as the new Gateway/Router. It still has some problems with IPv6 DHCP but otherwise is running just fine.&lt;/p&gt;
&lt;p&gt;So there you have it, a working cross-platform Continuous Integration system building Vala based projects. It's live on the internet now, so you can check it out &lt;a href="http://jenkins.valadate.org:8080"&gt;here&lt;/a&gt; (Github login required).&lt;/p&gt;
&lt;p&gt;OK, now we're ready to start building Valadate! Tune in again soon for Part 4. Who tests the tester?&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category><category term="Jenkins"></category><category term="Continuous Integration"></category><category term="DevOps"></category></entry><entry><title>Towards a Test Driven Development Framework in Vala Part 2. Requirements and System Architecture</title><link href="http://chrisdaley.biz/test-driven-development-in-vala-pt-2.html" rel="alternate"></link><updated>2016-01-13T10:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-13:test-driven-development-in-vala-pt-2.html</id><summary type="html">&lt;p&gt;Less than a week ago I &lt;a href="http://chrisdaley.biz/test-driven-development-in-vala-pt-1.html"&gt;posted&lt;/a&gt; a call for input on my proposal to build a Test Driven Development Framework for Vala and feedback has been slowly trickling in. You can see a summary &lt;a href="https://gist.github.com/chebizarro/6c949fafe1e9a2c59b26"&gt;here&lt;/a&gt; which has also been distilled into a &lt;a href="http://bit.ly/1ZSrRA6"&gt;Trello board&lt;/a&gt; which will become the Product Backlog and Product Roadmap. The list is looking fairly complete so far, so I figure I'm just about ready to close it off and work on a Release Plan. Then I can finally start writing code! Phew.&lt;/p&gt;
&lt;p&gt;The requirements gathered so far are pretty much in line with other testing frameworks, but here's a good time to review our Product Vision again and see if we're heading in the right direction. I've highlighted the parts of the statement which correspond to features so we can compare.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For Vala developers who need to test their code, &amp;lt; insert cool tool name &amp;gt; is a powerful testing framework that &lt;strong&gt;provides behavioral, functional and unit testing features&lt;/strong&gt; to help them write great Open Source software. Unlike other testing frameworks, &amp;lt; insert cool tool name &amp;gt; is &lt;strong&gt;designed especially for Vala&lt;/strong&gt; while &lt;strong&gt;integrating seamlessly into existing toolchains&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's look at that Requirements we've gathered so far and see if these features would meet this vision:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Product Backlog" src="http://chrisdaley.biz/images/requirements.png" /&gt;&lt;/p&gt;
&lt;h4&gt;provides behavioral, functional and unit testing features&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Test discovery&lt;/li&gt;
&lt;li&gt;Async tests&lt;/li&gt;
&lt;li&gt;Test Runner&lt;/li&gt;
&lt;li&gt;Support for Gherkin&lt;/li&gt;
&lt;li&gt;Asserts&lt;/li&gt;
&lt;li&gt;Test protected behavior&lt;/li&gt;
&lt;li&gt;Abstract Tests&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;designed especially for Vala&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Genie support&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;integrating seamlessly into existing toolchains&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Output TAP&lt;/li&gt;
&lt;li&gt;Compatible with gstester&lt;/li&gt;
&lt;li&gt;CLI and standalone GUI&lt;/li&gt;
&lt;li&gt;PIE binaries&lt;/li&gt;
&lt;li&gt;Integrate with CI tools like Jenkins&lt;/li&gt;
&lt;li&gt;Tests can compile and run without framework installed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So far so good! Of course, this is an Agile project, so this list is not exhaustive or final and we can expect some features to be added and others modified or removed altogether. The important thing is that our features align with our vision. The result of this prioritization process will be the Product Roadmap and the Product Backlog, which will guide sprints and daily development efforts and inform the release schedule. Before we do that though, we need some guidance on how to break these features up into functional areas which will determine how we structure our code base and where to start writing our tests. To do this we need a System Architecture.&lt;/p&gt;
&lt;h3&gt;The System Architecture and TDD&lt;/h3&gt;
&lt;p&gt;One of the misconceptions that newcomers to TDD have is that you don't write any code until you've written a test for it. This leaves many people new to the concept scratching their heads about where to start, as even creating a simple command line application requires a certain amount of boilerplate code to be written before you can even start processing the user's input. At this point, a lot of beginners may inadvertently write reams of redundant tests, start reinventing already well tested wheels or just give up on TDD altogether. There are very few times when your code will be executing without any dependencies (if only libc) so you will almost always be coding within an existing framework, if only loosely. Most of these interactions with other frameworks should be encapsulated in integration tests which are developed in parallel with the unit tests. The tests which inform our system design are those which test its unique features. Our System Architecture defines these interactions and boundaries and gives us a basic skeleton upon which to start laying down a codebase. Once this is in place, we can start writing actual tests.&lt;/p&gt;
&lt;p&gt;With a project like this we already have the advantage of several examples of prior art, chief amongst these the &lt;a href="https://en.wikipedia.org/wiki/XUnit"&gt;xUnit&lt;/a&gt; architecture. xUnit is a loose framework which includes JUnit and NUnit which stipulates that any implementation has a common architecture as shown in the diagram below:&lt;/p&gt;
&lt;p&gt;&lt;img alt="xUnit Class Diagram" src="http://chrisdaley.biz/images/architecture.png" /&gt;&lt;/p&gt;
&lt;p&gt;From this diagram we can already begin to see how we will structure the code. At a minimum we will be creating separate files and tests for Test, TestRunner, TestSuite, TestCase, TestFixture and TestResult. Yep, tests for tests. I may have said this would get interesting... This will give us the minimum we need to set up a toolchain, create a repository and start pushing to it. Hooray, we're about to start writing code! Except that it still doesn't have a name...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What's in a name? That which we call a rose by any other name would smell as sweet.&lt;/p&gt;
&lt;p&gt;William Shakespeare&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Thanks Bill. I'm still not 100% sold on Valadate, even though it does reflect the Product Vision of being made especially for Vala and that it's not strictly limited to unit testing. Calling it VUnit would reflect its XUnit origins, but it's not like there's any rigid API to conform to. Technically it doesn't matter at this stage of development, but I would like to avoid having to refactor the code later just to change the name. There's still some more work that can done before laying down any code, so I'll let it percolate for a day or two longer before making a firm decision. Now's a good a time as any to speak up if you feel passionately one way or the other.&lt;/p&gt;
&lt;p&gt;But at least it's got a logo! Let me know what you think...&lt;/p&gt;
&lt;p&gt;&lt;img alt="A stylized solar system seen at an oblique angle" src="http://chrisdaley.biz/images/valadate_logo.png" /&gt;&lt;/p&gt;
&lt;p&gt;The base was designed by &lt;a href="https://thenounproject.com/misirlou/"&gt;misirlou&lt;/a&gt; and I added the nice colors. It's meant to symbolize the eponymous asteroid that gives Vala its name.&lt;/p&gt;
&lt;p&gt;That's all for now, tune in again soon when I discuss the Roadmap and Backlog as well as how I set up Jenkins CI on a Raspberry Pi.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Farewell oh Thin White Duke - a tribute to David Bowie in Vala</title><link href="http://chrisdaley.biz/farewell-duke.html" rel="alternate"></link><updated>2016-01-11T17:00:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-11:farewell-duke.html</id><summary type="html">&lt;p&gt;I was looking at the asteroid 131 Vala, the origin of the programming language's name, on the &lt;a href="http://ssd.jpl.nasa.gov/sbdb.cgi?sstr=131;cad=1;old=0;orb=1;cov=0;log=0#orb"&gt;JPL Small Object Database&lt;/a&gt; when I heard the sad news of David Bowie's passing. Like many of my age, I grew up not knowing of a world without space travel, the threat of nuclear war or the Thin White Duke. No other artist captured that sense of both wonder and fear of a species walking a tight rope towards its destiny. Would we stumble and fall into oblivion or would we make it to the stars? Were all our heros like Major Tom? Brittle and flawed yet compellingly corageous.  &lt;/p&gt;
&lt;p&gt;I was thinking these things and more while browsing the JPL website and I noticed that the venerable old Orbit Viewer applet was no longer working. I wanted to watch some celestial bodies move that morning to the sounds of David Bowie so I downloaded the applet source and ported it to Vala. For the music, I added a small gstreamer player that loads and plays a midi file from &lt;a href="http://www.midiworld.com/files/1018/"&gt;midiworld.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
&lt;iframe allowfullscreen="true" frameborder="0" height="315" src="//www.youtube.com/embed/4lQcdikEdJU" width="560"&gt;&lt;/iframe&gt;
&lt;/p&gt;
&lt;p&gt;Porting Java code to Vala is relatively easy, especially when it is older code and doesn't have too many of the odd little workarounds that have crept into the language over the years. The quickest part was the library of functions for calculating the orbits, as this is pretty much pure math. The trickiest bit was the interface, which I recreated in Glade and the drawing routines for animating the whole thing. I have been working on a port of the Box2D physics engine, so I have already solved most of these problems before. The end result you see above.&lt;/p&gt;
&lt;p&gt;It still needs some work before it's complete - only the play button works and there's no way to adjust the viewport yet, but these are fairly trivial to implement. If anyone is interested in the code, I'll post a link to a Github repo - both the physics and animation routines are particularly interesting if you're starting out, even with the lack of comments.&lt;/p&gt;
&lt;p&gt;Thanks for watching, and thanks Starman, for all those Golden Years...&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="JPL"></category><category term="David Bowie"></category></entry><entry><title>Towards a Test Driven Development Framework in Vala Part 1.</title><link href="http://chrisdaley.biz/test-driven-development-in-vala-pt-1.html" rel="alternate"></link><updated>2016-01-08T10:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-08:test-driven-development-in-vala-pt-1.html</id><summary type="html">&lt;p&gt;I first came across &lt;a href="https://wiki.gnome.org/Projects/Vala"&gt;Vala&lt;/a&gt; when scoping out the possibility of updating a venerable old Open Source program from GTK+2 to GTK+3. I wasn't quite sure what to make of Vala at first - it was an Object Oriented Programming language based on the GObject type system that used C as an intermediary language for the gcc compiler. I looked through a bunch of the samples, and was struck by the elegance and parsimony of the syntax and how instantly understandable it was from my familiarity with Java and C#. I played with a few example apps and I was surprised at how much fun it was to use as well. It was GObject without the endless reams of boilerplate code. Properties actually made sense now and using signals is a snap. IDE support was about as good as any other language, especially in Geany, my tool of choice. I was hooked.&lt;/p&gt;
&lt;p&gt;There was only one problem. I'm a big fan of &lt;a href="https://en.wikipedia.org/wiki/Test-driven_development"&gt;TDD&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Behavior-driven_development"&gt;BDD&lt;/a&gt; and after many hours of intense Google-Fu, I was able to find precious little on the topic in regards to Vala. What &lt;a href="https://esite.ch/2012/06/writing-tests-for-vala/"&gt;there was&lt;/a&gt; boiled down to using the GLib Test library and a nice little adapter class to group individual test cases into a test suite. The end result was run through &lt;code&gt;gtester&lt;/code&gt; on the command line, usually as part of a toolchain like Autotools. This was straightforward enough for simple applications with limited user interactions, but it doesn't really scale for BDD. Some work had been done on a framework called &lt;a href="https://github.com/yorba/valadate"&gt;Valadate&lt;/a&gt; but it was abandoned by its maintainers a few years ago. This was a real blocker for me going forward. My philosophy is that you can occasionally write great software in moments of furious creativity but it takes boring old testing to consistently produce good software. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Feel the hate flow throw you" src="http://chrisdaley.biz/images/unit-tests-dv.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Feel the hate flow throw you&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The thing with Free and Open Source Software is that it's only free at the cashier. Once you get it home you have to pay an ongoing maintenance cost in time if you want to keep using it. That time could be spent making minor contributions like filing bug reports through to helping new users in forums or translating apps all the way to implementing features yourself. I see real potential in Vala but I feel that it's usability is being hampered by this missing feature. The developers of the language have given the world a great gift and their time is better spent maintaining it. The current solution is &lt;em&gt;mostly&lt;/em&gt; good enough, but generates a lot of extra code to be maintained and has no support for BDD. "Somebody should do something about it" is a phrase that makes me groan whenever I hear it, because I usually think that that someone should be the person saying it. Well, someone should do something about it.&lt;/p&gt;
&lt;p&gt;So this blog post is an effort to get the ball rolling on that something. Although I have some free time now, it's not an endless wellspring. I also don't want to start a vaporware or abandonedware project that gets added to the list of good ideas people had at one point in time. I would like to build something that is sustainable, that evolves with its users and that could be easily passed on to other maintainers should I no longer have enough time to devote to it. I imagine this has been the manifesto of a thousand failed Open Source projects, but it's better than nothing, so here goes...&lt;/p&gt;
&lt;h3&gt;Getting the ball rolling&lt;/h3&gt;
&lt;p&gt;Since this a project to bring TDD and BDD to Vala, I would like to use Agile techniques to plan and develop it. The first steps in this case are setting up a Product Vision and Requirements Gathering. I'll take a stab at the first one (quoted because VISION STATEMENT).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For Vala developers who need to test their code, &amp;lt; insert cool tool name &amp;gt; is a powerful testing framework that provides behavioral, functional and unit testing features to help them write great Open Source software. Unlike other testing frameworks, &amp;lt; insert cool tool name &amp;gt; is designed especially for Vala while integrating seamlessly into existing toolchains.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I guess that makes me the Product Owner as well. I don't really care what it's called, Valadate is as good as any but I'm open to suggestions. If there are enough ideas we might have a poll.&lt;/p&gt;
&lt;p&gt;The next step will be the Requirements Gathering, one I have a number of ideas about already but I would really like to hear from the potential end users. I've started a Trello Board to that effect and if you would like to suggest a feature or comment on one that's already there, &lt;a href="http://bit.ly/1ZSrRA6"&gt;head on over&lt;/a&gt; and make yourself heard. If that's not your medium, you can ping me on &lt;a href="http://twitter.com/chebizarro"&gt;Twitter&lt;/a&gt; or hit me up on the Vala IRC channel (irc.gimp.org #vala), as &lt;code&gt;bizarro&lt;/code&gt;. A tool like this will live or die on its fitness for purpose, so please don't hold back.&lt;/p&gt;
&lt;p&gt;That's all for now, in the next post I'll summarize the requirements that have been gathered so far and lay out the options for the system architecture as well as a provisional schedule for the first release. Thanks for tuning in and don't forget to join the conversation if you have something to add.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Gherkin for Vala</title><link href="http://chrisdaley.biz/gherkin-for-vala.html" rel="alternate"></link><updated>2016-01-04T20:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-04:gherkin-for-vala.html</id><summary type="html">&lt;p&gt;I've had some spare time recently to work on some pet projects and get them into a decent enough shape that they could be subjected to the withering gaze of the Panopticon. One in particular is a port of the Gherkin language to Vala. So what is Gherkin exactly and why should you care?&lt;/p&gt;
&lt;p&gt;From the &lt;a href="https://github.com/cucumber/cucumber/wiki/Gherkin"&gt;Gherkin wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gherkin is the language that &lt;a href="https://cucumber.io/"&gt;Cucumber&lt;/a&gt; understands. It is a Business Readable, Domain Specific Language that lets you describe software’s behaviour without detailing how that behaviour is implemented.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Gherkin is available for a host of languages and is tightly integrated into JUnit for example. Its syntax is pretty straightforward and designed to be intelligible by non-technical people:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  Feature: Some terse yet descriptive text of what is desired
  Textual description of the business value of this feature
  Business rules that govern the scope of the feature
   Any additional information that will make the feature easier to understand

   Scenario: Some determinable business situation
     Given some precondition
       And some other precondition
      When some action by the actor
       And some other action
       And yet another action
      Then some testable outcome is achieved
       And something else we can check happens too

   Scenario: A different situation
       ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Gherkin parser for Vala, which you can get &lt;a href="https://github.com/chebizarro/gherkin-vala"&gt;here&lt;/a&gt; reads in Feature files and builds a tree of elements that can then either be manipulated directly or output as JSON.&lt;/p&gt;
&lt;p&gt;The parser by itself is not tremendously useful, but is one of the building blocks for a comprehensive testing framework for Vala and by extension, GObject that I am presently scoping. If this is something you're interested in, and I assume it is since you've read this far, then I'd encourage you to join the conversation.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry></feed>