<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Enter the Panopticon</title><link href="http://chrisdaley.biz/" rel="alternate"></link><link href="http://chrisdaley.biz/feeds/all.atom.xml" rel="self"></link><id>http://chrisdaley.biz/</id><updated>2016-03-31T15:00:00-07:00</updated><entry><title>Towards a Test Driven Development Framework in Vala Part 6. First Release!</title><link href="http://chrisdaley.biz/test-driven-development-in-vala-pt-6.html" rel="alternate"></link><updated>2016-03-31T15:00:00-07:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-03-31:test-driven-development-in-vala-pt-6.html</id><summary type="html">&lt;p&gt;Well, it turns out that managing a Rock Band is more time consuming than I first thought, especially if they're getting ready to release their first album. It also turns out that building Debian packages is hard as well, particularly if you're trying to set up a Jenkins CI system to automate the process. Despite all this, I'm only a few weeks behind my initially projected release date and I'm pretty excited to announce that the day has finally come and Version 1.0 of Valadate is now ready for public consumption!&lt;/p&gt;
&lt;p&gt;I'll go through the full feature set (warts and all) shortly, but for those who can't wait to dive in, here's how you can install it...&lt;/p&gt;
&lt;h4&gt;From Source&lt;/h4&gt;
&lt;p&gt;For the adventurous, you can download the source and build and install it yourself. You will need to have the automake toolchain set up on your system and the development libraries for the following installed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;glib-2.0&lt;/li&gt;
&lt;li&gt;libxml-2.0&lt;/li&gt;
&lt;li&gt;libxslt&lt;/li&gt;
&lt;li&gt;json-glib-1.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You'll also need Gtk-Doc and Valadoc if you want to build the API documentation.&lt;/p&gt;
&lt;p&gt;Grab the source:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/chebizarro/valadate.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;In the source directory run:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;./autogen.sh
make
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;You can pass the &lt;code&gt;--enable-docs&lt;/code&gt; flag to autogen.sh if you have Valadoc and Gtk-Doc installed and it will build the API documentation in the docs directory.&lt;/p&gt;
&lt;p&gt;To install, you then just need to run the following with root privileges:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make install&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;And that's it, you should be ready to roll. Of course, you'll need to go through this process everytime there's a new release so it might be easier to just install it using your system's package manager. Depending on what that is, you can do the following:&lt;/p&gt;
&lt;h4&gt;Debian&lt;/h4&gt;
&lt;p&gt;Add the repository's key&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;curl https://www.valadate.org/jenkins@valadate.org.gpg.key | sudo apt-key add -
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Add the following to your Software Sources:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;deb&lt;/span&gt; &lt;span class="s"&gt;https://www.valadate.org/repos/debian&lt;/span&gt; &lt;span class="kp"&gt;valadate&lt;/span&gt; &lt;span class="kp"&gt;main&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then you can install Valadate with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get update
sudo apt-get install valadate
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Fedora 23&lt;/h4&gt;
&lt;p&gt;Add the following to /etc/yum.repos.d/valadate.repo&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[valadate]&lt;/span&gt;
&lt;span class="na"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;valadate&lt;/span&gt;
&lt;span class="na"&gt;baseurl&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;http://www.valadate.org/repos/fedora/$releasever/$basearch&lt;/span&gt;
&lt;span class="na"&gt;repo_gpgcheck&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;1&lt;/span&gt;
&lt;span class="na"&gt;gpgcheck&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;1&lt;/span&gt;
&lt;span class="na"&gt;enabled&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;1&lt;/span&gt;
&lt;span class="na"&gt;gpgkey&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;http://www.valadate.org/jenkins@valadate.org.gpg.key&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Then run with root privileges:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;dnf update
dnf install valadate
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Those are the distributions that are available so far, but there's a Homebrew package for Mac OS X that's more or less ready to push. Given the way Valadate works, a Windows release will probably be a little while off as there are a few platform specific issues to be worked through. If you have favourite platform that you would like to see packaged, submit an issue on GitHub and I'll see what I can do.&lt;/p&gt;
&lt;p&gt;So now you've got Valadate, how do you use it?&lt;/p&gt;
&lt;p&gt;The easiest way is to create a Sub Class of the TestCase Abstract Class and add test methods to it, which are any that start with &lt;code&gt;test_&lt;/code&gt;, have no parameters and return &lt;code&gt;void&lt;/code&gt;. These methods will then be detected and executed automatically at runtime.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BookTest&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Valadate&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Framework&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TestCase&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;test_construct_book&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="c1"&gt;// Arrange ...&lt;/span&gt;

        &lt;span class="c1"&gt;// Act ...&lt;/span&gt;

        &lt;span class="c1"&gt;// Assert ...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To compile, pass the following flags and parameters where mytest-0.vala is the source code file containing the above test. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ valac --library mytest-0 --gir mytest-0.gir --pkg valadate-1.0 -X -pie -X -fPIE mytest-0.vala
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In order for everything to work correctly, the name of the output binary needs to exactly match that of the .gir file (less the file extension). This will then generate an executable which can be run on the Command Line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ ./mtest-0

/LibraryBookTest/construct_book: ** Message: mytest-0.vala:15: running

OK
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;To run the test binary with &lt;a href="https://testanything.org/"&gt;TAP&lt;/a&gt; output pass the --tap flag:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ ./mtest-0 --tap

&lt;span class="c1"&gt;# random seed: R02Sddf35dad90ff6d1b6603ccb68028a4f0&lt;/span&gt;

1..1

&lt;span class="c1"&gt;# Start of LibraryBookTest tests&lt;/span&gt;

** Message: mytest-0.vala:15: running

ok &lt;span class="m"&gt;1&lt;/span&gt; /LibraryBookTest/construct_book

&lt;span class="c1"&gt;# End of LibraryBookTest tests&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The &lt;code&gt;[Test]&lt;/code&gt; annotation and parameters are also available for giving test classes and methods more readable names and for supporting asynchronous tests.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Annotated TestCase with name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyTest&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Valadate&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Framework&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TestCase&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Annotated Method With Name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;annotated_test_with_name&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;assert_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;


    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Asynchronous Test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;timeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;async&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;test_async&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;assert_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skip&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;yes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;skip_test&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;assert_true&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mtest&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;tap&lt;/span&gt;

&lt;span class="mf"&gt;1..3&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="n"&gt;Start&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Annotated&lt;/span&gt; &lt;span class="n"&gt;TestCase&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;tests&lt;/span&gt;
&lt;span class="n"&gt;ok&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Annotated&lt;/span&gt; &lt;span class="n"&gt;TestCase&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Annotated&lt;/span&gt; &lt;span class="n"&gt;Method&lt;/span&gt; &lt;span class="n"&gt;With&lt;/span&gt; &lt;span class="n"&gt;Name&lt;/span&gt;
&lt;span class="n"&gt;ok&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Annotated&lt;/span&gt; &lt;span class="n"&gt;TestCase&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Asynchronous&lt;/span&gt; &lt;span class="n"&gt;Test&lt;/span&gt;
&lt;span class="n"&gt;ok&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Annotated&lt;/span&gt; &lt;span class="n"&gt;TestCase&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;skip_test&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="n"&gt;SKIP&lt;/span&gt; &lt;span class="n"&gt;Skipping&lt;/span&gt; &lt;span class="n"&gt;Test&lt;/span&gt; &lt;span class="n"&gt;skip_test&lt;/span&gt;
&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="n"&gt;End&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Annotated&lt;/span&gt; &lt;span class="n"&gt;TestCase&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;tests&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Testing Gtk applications&lt;/h4&gt;
&lt;p&gt;If you want to test Gtk based applications you will need to use the &lt;a href="http://github.com/chebizarro/valadate-gtk"&gt;valadate-gtk&lt;/a&gt; package (available in the same repository). It's usage is almost identical:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ valac --library mytest-0 --gir mytest-0.gir --pkg valadate-gtk-1.0 -X -pie -X -fPIE mytest-0.vala
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The valadate-gtk package makes sure the Gkt Test environment is properly loaded and configured, otherwise you will get all sorts of funky errors.&lt;/p&gt;
&lt;h4&gt;RTFM&lt;/h4&gt;
&lt;p&gt;The &lt;a href="https://github.com/chebizarro/valadate/wiki"&gt;Wiki&lt;/a&gt; is pretty scant at the moment but will eventually have detailed instructions on installing and setting up your toolchain with Valadate as well as integrating it with Continuos Integration systems. &lt;/p&gt;
&lt;p&gt;There are a number of sample projects available &lt;a href="https://github.com/chebizarro/valadate-examples"&gt;here&lt;/a&gt; which showcase Valadate's features and how to use it with different toolchains and platforms. This will be continuously updated as new features are added.&lt;/p&gt;
&lt;p&gt;The API reference for Vala can be found &lt;a href="http://www.valadate.org/docs/valadoc/valadate/index.htm"&gt;here&lt;/a&gt; and for C &lt;a href="http://www.valadate.org/docs/gtkdoc/html/"&gt;here&lt;/a&gt;. These documents are automatically generated by Jenkins whenever a new release is made so should always be up-to-date.&lt;/p&gt;
&lt;h3&gt;Next steps...&lt;/h3&gt;
&lt;p&gt;Obviously (hopefully), there will be a tsunami of bug reports once people start using it and finding them. I've tested it on a large array of platforms but there's no saying what will happen once it's in the wild. Aside from that, I am very much keen to get to work on adding BDD support via Gherkin and gradually replacing some of the crustier and more unwieldly elements of GTest under the hood. This will have to come in the time I can find between my regular consulting work which has recently taken off in a big way, and managing a Rock band that's just about to put an album out. Good times!&lt;/p&gt;
&lt;p&gt;&lt;img alt="We salute you" src="http://chrisdaley.biz/images/skype-rock.png" /&gt;&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category><category term="CoC"></category></entry><entry><title>Towards a Test Driven Development Framework in Vala Part 5 - Minimum Viable Product</title><link href="http://chrisdaley.biz/test-driven-development-in-vala-pt-5.html" rel="alternate"></link><updated>2016-02-20T10:00:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-02-20:test-driven-development-in-vala-pt-5.html</id><summary type="html">&lt;p&gt;Things have really been moving quickly since I last posted, with the development branch really starting to take shape. When I sat down to look at the list of requirements, I decided that the best place to start for a first release would be to at least replicate the same feature set of the original. To recap, those were:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Automatic test discovery like JUnit or .NET testing framework.&lt;/li&gt;
&lt;li&gt;Running tests for all parameters from specific set.&lt;/li&gt;
&lt;li&gt;Utility functions for waiting in a main loop until specified event or
    timeout occurs.&lt;/li&gt;
&lt;li&gt;Support for asynchronous tests. Method declared async in vala will be
    automatically run under main loop until completion or configurable
    timeout.&lt;/li&gt;
&lt;li&gt;Utility functions providing temporary directory to tests.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These have been translated into GitHub &lt;a href="https://github.com/chebizarro/valadate/issues"&gt;issues&lt;/a&gt; and the Waffle &lt;a href="https://waffle.io/chebizarro/valadate"&gt;board&lt;/a&gt; as well as a few additional features that I thought should make the first cut, namely:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/chebizarro/valadate/issues/6"&gt;Geanie support&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/chebizarro/valadate/issues/1"&gt;Working examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These have all been added to the Version 1.0.0 &lt;a href="https://github.com/chebizarro/valadate/milestones/Version%201.0.0"&gt;milestone&lt;/a&gt; and
well, I'm pleased to say that after a little under two weeks of concerted effort, I have (re)implemented almost all of the above features! Based on the level of effort so far, I am now envisaging an initial release as early as the 1st of March.&lt;/p&gt;
&lt;p&gt;I'm actually pretty excited about what has come out of the process so far. One of the original itches I set out to scratch was the verbosity of unit tests in Vala and through the voodoo of xml/xslt/json and GModule I believe I have achieved that. While the implementation details are frankly a little scary, the resulting user facing API hides them quite nicely.&lt;/p&gt;
&lt;p&gt;With a correctly configured build script, using Valadate is as easy as declaring a subclass of &lt;code&gt;TestCase&lt;/code&gt; and adding annotated instance methods like so: &lt;/p&gt;
&lt;script src="http://gist-it.appspot.com/https://github.com/chebizarro/valadate/blob/version-1.0.0/tests/libvaladate/data/testexetwo.vala?slice=18:"&gt;&lt;/script&gt;

&lt;p&gt;That's it. No &lt;code&gt;main&lt;/code&gt; function required, no need to add tests in the &lt;code&gt;TestCase&lt;/code&gt; constructor. Clean and simple, the way it should be. The code snippet above is a real live test from the Valadate framework (the actual test of the test, so to speak) and it runs beautifully, producing TAP output both to file and to the terminal -&lt;/p&gt;
&lt;p&gt;&lt;img alt="Love that green!" src="http://chrisdaley.biz/images/terminal.png" /&gt;&lt;/p&gt;
&lt;p&gt;Astute readers will notice that it is still GLib.Test running things under the hood, although it is sufficiently encapsulated to allow its gradual replacement without affecting the way end users write their tests. It should now be possible to add things like events and notifications without breaking user's code.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;TestRunner&lt;/code&gt; class handles test discovery via a Gir file output when the test is compiled. This was a key concept of the original Valadate but I took it a step further, combining it with GModule to create a kind of "poor person's" Introspection module. The test binary needs to be compiled as a Position Independent Executable (PIE) for this to work which is presently only supported on Linux and Mac OSX, although the fundamentals should apply to executable DLLs on Windows as well. &lt;/p&gt;
&lt;p&gt;The &lt;code&gt;TestRunner&lt;/code&gt; currently supports &lt;code&gt;[Test], [AsyncTest]&lt;/code&gt; and &lt;code&gt;[SkipTest]&lt;/code&gt; with parameters. Although it is trivial to add new annotations, I am going to keep them to a minimum and move to a plugin based model which will allow plugins to decorate and control how test methods are run.&lt;/p&gt;
&lt;p&gt;Of course, if all of this is a little too funky for you, you can still do things the old way by adding each test method in the TestCase's constructor:&lt;/p&gt;
&lt;script src="http://gist-it.appspot.com/https://github.com/chebizarro/valadate/blob/version-1.0.0/tests/libvaladate/utils/testsignalwaiter.vala?slice=42:47"&gt;&lt;/script&gt;

&lt;p&gt;and providing your own &lt;code&gt;main&lt;/code&gt; entry point like so:&lt;/p&gt;
&lt;script src="http://gist-it.appspot.com/https://github.com/chebizarro/valadate/blob/version-1.0.0/tests/libvaladate/utils/main.vala?slice=2:12"&gt;&lt;/script&gt;

&lt;p&gt;in this case, you don't need to compile it as a PIE binary or add the Method annotations (they won't work anyway). You can still use all of Valadate's other awesome features such as asynchronous tests, you'll just have more redundant code to manage.&lt;/p&gt;
&lt;p&gt;With this feature now implemented and on the way to being solidly tested, I feel it's time to merge the development branch and roll a release. That way I can start getting feedback (and bug reports) on what's been done so far before implementing the meatier features like Gherkin integration and a GUI.&lt;/p&gt;
&lt;p&gt;It goes without saying that the only way anybody will be able to use Valadate is if there is clear documentation and working examples, so to this end there are now several &lt;a href="https://github.com/chebizarro/valadate/tree/version-1.0.0/examples"&gt;example projects&lt;/a&gt; and a &lt;a href="https://github.com/chebizarro/valadate/wiki"&gt;Wiki&lt;/a&gt;. I've also added support for building Valadoc and GtkDoc docs from the project source tree. There's still a bit of work to do before the first release, but the infrastructure is now in place (and I can close &lt;a href="https://github.com/chebizarro/valadate/issues/1"&gt;issue #1&lt;/a&gt;!).&lt;/p&gt;
&lt;p&gt;So that's all I'm going to go into in this post, so I can get back to documenting the work I've done and getting the release ready for deployment. The next post on Valadate will be about the release, so now's a good a time as any to jump in and let me know what you think, in the comments below or in the "usual" places. Thanks for watching!&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category><category term="CoC"></category></entry><entry><title>Hacia un framework de desarrollo guiado por pruebas para Vala - quinta parte - Producto Viable Mínimo</title><link href="http://chrisdaley.biz/es/test-driven-development-in-vala-pt-5.html" rel="alternate"></link><updated>2016-02-20T10:00:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-02-20:es/test-driven-development-in-vala-pt-5.html</id><summary type="html">&lt;p&gt;Las cosas se han ido a toda maquina desde mi ultimo post, con la rama de desarrollo concretizandose paso por paso. Cuando me senté a examinar la lista de los requisitos, decidí que el mejor punto de partida para iniciar la primera versión sería, por lo menos,  replicar el mismo conjunto de características del original. En resumen, esos eran:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Descubrimiento de pruebas como el JUnit o el .NET framework de pruebas&lt;/li&gt;
&lt;li&gt;Ejecutar pruebas para todos los parámetros de un conjunto especifico&lt;/li&gt;
&lt;li&gt;Funciones de utilidad para esperar en el circuito main hasta que un evento específico o timeout ocurre&lt;/li&gt;
&lt;li&gt;Apoyo para Pruebas asincrónicas. Un método declarado async en Vala sera ejecutado en el circuito main hasta se acaba o después de un timeout configurable.&lt;/li&gt;
&lt;li&gt;Funciones de utilidad que aportan directorios temporales a las pruebas.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Estos se han traducido en &lt;a href="https://github.com/chebizarro/valadate/issues"&gt;temas&lt;/a&gt; de GitHub y la &lt;a href="https://waffle.io/chebizarro/valadate"&gt;placa&lt;/a&gt; de Waffle además de algunas características que pienso deberían ser incluidos en el primer corte, es decir:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/chebizarro/valadate/issues/6"&gt;Apoyo para Geanie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/chebizarro/valadate/issues/1"&gt;Ejemplos prácticos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Todas esas características se han sido añadido al &lt;a href="https://github.com/chebizarro/valadate/milestones/Version%201.0.0"&gt;hito&lt;/a&gt; de la versión 1.0.0 y pues bien, me da mucho placer de decir que después de un poco menos de dos semanas de esfuerzo concertado, he (re) aplicado casi todas las características anteriores! Tomando en cuenta en el nivel de esfuerzo gastado hasta ya, tengo previsto el lanzamiento inicial tan pronto como el 1 de marzo.&lt;/p&gt;
&lt;p&gt;De veras, me entusiasma mucho lo que ha salido del proceso hasta ya. Uno de los picores originales que intentaba rascar al inicio fue el nivel de detalle de las pruebas unitarias en Vala y ya a través del vudú de XML/XSLT/JSON y GModule creo que lo he logrado. Pues bien, aunque los detalles de la implementación sean francamente un poco espantosos, la API que enfrenta al usuario los esconde bastante bien.&lt;/p&gt;
&lt;p&gt;Con una script de construcción configurada correctamente, el uso de Valadate es tan fácil como declarar una subclase de &lt;code&gt;TestCase&lt;/code&gt; y añadir unos métodos de instancia anotada así:&lt;/p&gt;
&lt;script src="http://gist-it.appspot.com/https://github.com/chebizarro/valadate/blob/version-1.0.0/tests/libvaladate/data/testexetwo.vala?slice=18:"&gt;&lt;/script&gt;

&lt;p&gt;Y ya esta. No se requiere una función &lt;code&gt;main&lt;/code&gt;, no hay que agregar las pruebas el en constructor de la &lt;code&gt;TestCase&lt;/code&gt;. Limpio y sencillo, así como debería ser. El fragmento de código arriba es una prueba real en directo del framework Valadate (la prueba real de la prueba, digamos...) y funciona muy bien, produciendo la salida de TAP tanto en un archivo al terminal -&lt;/p&gt;
&lt;p&gt;&lt;img alt="Love that green!" src="http://chrisdaley.biz/images/terminal.png" /&gt;&lt;/p&gt;
&lt;p&gt;Los lectores astutos se dará cuenta de que todavía es GLib.Test lo que manda debajo el capó, aunque esta encapsulado suficientemente para permitir su sustitución gradual sin afectar como los usuarios escriben sus pruebas. Ahora debería ser posible añadir características como eventos y notificaciones sin romper el código del usuario.&lt;/p&gt;
&lt;p&gt;La clase &lt;code&gt;TestRunner&lt;/code&gt; maneja el descubrimiento de pruebas a través de un archivo de Gir creado cuando se compila la prueba. Este fue un concepto clave de la versión original de Valadate, pero me tomó un paso más allá, combinándolo con GModule para crear una especie de módulo de introspección "de los pobres". El binario de prueba necesita ser compilado como un ejecutable independiente de posición (PIE) para que esto funcione, lo que está actualmente solamente soportado en Linux y Mac OS X, aunque los fundamentos deben aplicarse a las DLL ejecutables en Windows también.&lt;/p&gt;
&lt;p&gt;La &lt;code&gt;TestRunner&lt;/code&gt; actualmente soporta &lt;code&gt;[Test]&lt;/code&gt;, &lt;code&gt;[AsyncTest]&lt;/code&gt; y &lt;code&gt;[SkipTest]&lt;/code&gt; con parámetros. Aunque sea trivial añadir nuevas anotaciones, voy a mantenerlos al mínimo y usar un modelo basado en complementos que les permitirá decorar y controlan cómo se ejecutan los métodos de prueba.&lt;/p&gt;
&lt;p&gt;Por supuesto, si todo eso te parece demasiado raro, todavía puedes hacer las cosas en la manera antigua mediante la adición de cada método de prueba en el constructor de la TestCase:&lt;/p&gt;
&lt;script src="http://gist-it.appspot.com/https://github.com/chebizarro/valadate/blob/version-1.0.0/tests/libvaladate/utils/testsignalwaiter.vala?slice=42:47"&gt;&lt;/script&gt;

&lt;p&gt;y el proporcionamiento de tu propio punto de entrada &lt;code&gt;main&lt;/code&gt; así:&lt;/p&gt;
&lt;script src="http://gist-it.appspot.com/https://github.com/chebizarro/valadate/blob/version-1.0.0/tests/libvaladate/utils/main.vala?slice=2:12"&gt;&lt;/script&gt;

&lt;p&gt;en este caso, no se necesita compilar como binario PIE o añadir las anotaciones de los métodos (no van a funcionar, de todas formas). Aun puedes usar las otras características impresionantes como las pruebas asincrónicas, aunque vas a tener más código redundante para gestionar.&lt;/p&gt;
&lt;p&gt;Con esta característica ya implementada y en el camino de ser probado sólidamente, me parece que es la hora de fusionar la rama de desarrollo y rollar un lanzamiento. Así que puedo empezar a recibir las reacciones (y los informes de error) a lo que hay antes de la aplicación de las características más sustanciosos como la integración de Gherkin y una interfaz gráfica de usuario.&lt;/p&gt;
&lt;p&gt;No hace falta decir que los usuarios no serán capaces de utilizar Valadate bien si no hay documentación clara y ejemplos funcionales, entonces he armado varios &lt;a href="https://github.com/chebizarro/valadate/tree/version-1.0.0/examples"&gt;proyectos de ejemplo&lt;/a&gt; y un &lt;a href="https://github.com/chebizarro/valadate/wiki"&gt;wiki&lt;/a&gt;. También he añadido soporte para la construcción de los documentos de Valadoc y GtkDoc en el árbol de código fuente del proyecto. Todavía se queda un poquito de trabajo antes de la primera versión, pero la infraestructura ya esta montado (y puedo cerrar &lt;a href="https://github.com/chebizarro/valadate/issues/1"&gt;issue # 1&lt;/a&gt;!).&lt;/p&gt;
&lt;p&gt;Pues nada, voy a terminar este post aca, pa que pueda volver a documentar el trabajo hecho hasta ahora y preparar el lanzamiento para su despliegue. La siguiente entrada sobre Valadate seria sobre el lanzamiento, así que ahora es un buen momento para decir lo que piensas, en los comentarios o en los lugares "habituales". Gracias por tu atención!&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Código Abierto"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Towards a Test Driven Development Framework in Vala Part 4. Who Tests the Tester?</title><link href="http://chrisdaley.biz/test-driven-development-in-vala-pt-4.html" rel="alternate"></link><updated>2016-02-04T16:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-02-04:test-driven-development-in-vala-pt-4.html</id><summary type="html">&lt;p&gt;After a short break to work on one of my other projects (&lt;a href="http://www.last.fm/music/Calisse"&gt;a Rock 'n Roll band&lt;/a&gt;) and finish setting up &lt;a href="http://jenkins.valadate.org:8080"&gt;Jenkins&lt;/a&gt;, I'm back at work on the project now officially known as &lt;a href="https://github.com/chebizarro/valadate"&gt;Valadate&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As I've mentioned before, there were some initial attempts at developing a TDD framework for Vala, the most extensive of them being &lt;a href="https://github.com/yorba/valadate"&gt;Valadate&lt;/a&gt;. After some consideration, and a review of the existing codebase, I decided that the most practical approach would be to assume maintainership of it and refactor/rewrite as necessary to meet the new requirements that have been &lt;a href="http://bit.ly/1ZSrRA6"&gt;gathered&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Presently, the existing Valadate package provides a number of utility classes for such things as asynchronous tests and temporary directories as well as a command line Test Runner. The procedure for writing tests is to create a concrete implementation of the Valadate Fixture interface with each unit test being a method whose name starts with &lt;code&gt;test_&lt;/code&gt;. The test is then compiled into a binary (shared library) which is run by the Test Runner. Test discovery is done by loading the .vapi and .gir files generated by Vala when the binary is compiled. The build system is &lt;a href="https://en.wikipedia.org/wiki/Waf"&gt;Waf&lt;/a&gt;, but for the purposes of reviewing the code, I ported it to autotools, a build system I am more comfortable with.&lt;/p&gt;
&lt;p&gt;The code compiles, but it has suffered from some bitrot, with quite a number of deprecation warnings, especially the asynchronous tests. The actual framework is quite lean and uses the GLib Test and TestSuite classes to group and run the tests it finds in the binary. In total there probably isn't more than 1000 SLOC in the whole project. While I see some interesting ideas in the current code, I have decided that the best approach is to start again from scratch and incorporate whatever is useful and send the remainder to binary heaven || hell.&lt;/p&gt;
&lt;p&gt;So now that I have the repository for Valadate setup and updated to build with autotools, I will use this as the &lt;code&gt;master&lt;/code&gt; from which we will derive the various development branches, using the widely practiced &lt;a href="https://guides.github.com/introduction/flow/"&gt;"GitHub Flow"&lt;/a&gt;, a repository management process which embodies the principles of Continuous Integration. In a nutshell, it involves six discrete steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a branch for developing a new feature&lt;/li&gt;
&lt;li&gt;Add commits to the branch&lt;/li&gt;
&lt;li&gt;Open pull requests&lt;/li&gt;
&lt;li&gt;Discuss and review the code&lt;/li&gt;
&lt;li&gt;Deploy&lt;/li&gt;
&lt;li&gt;Merge&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The underlying principle (or "one rule" as GitHub calls it) is that the &lt;code&gt;master&lt;/code&gt; branch is always deployable - which in the case of a tool like Valadate means it can be pulled, compiled and run at any time. So while the existing &lt;code&gt;master&lt;/code&gt; branch of Valadate is not exactly production ready, it is in the state where the Yorba Foundation stopped maintaining it. This at least gives us a baseline from which to start and some continuity with the original project, if only giving credit to the original developers for their hard work.&lt;/p&gt;
&lt;p&gt;We're ready to branch our new version, so what do we call it? The most commonly used system is &lt;a href="http://semver.org/spec/v2.0.0.html"&gt;Semantic Versioning&lt;/a&gt; which follows the MAJOR.MINOR.PATCH convention:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MAJOR version when you make incompatible API changes,&lt;/li&gt;
&lt;li&gt;MINOR version when you add functionality in a backwards-compatible manner, and&lt;/li&gt;
&lt;li&gt;PATCH version when you make backwards-compatible bug fixes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The last release of Valadate was 0.1.1 and it's not entirely clear if they were strictly following the Semantic Versioning scheme. There are separate API and SO version numbers which may not be applicable in our first release. So for simplicity, I will use the original version number as the starting point. As we are going to make some fairly substantial changes that would break the hell out of the 0 API, we should probably increment that to 1. Since we are starting from scratch, the MINOR version will revert to 0 as well. So the branch name that we will begin working on our new implementation under will be 1.0.0.&lt;/p&gt;
&lt;p&gt;Sweet. Let's dial up those digits:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git checkout -b version-1.0.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The local repository is now a new branch called &lt;code&gt;version-1.0.0&lt;/code&gt;, which will allow us to start really overhauling the code without affecting the "deployable" &lt;code&gt;master&lt;/code&gt; branch. Since we're going to break more things than a stoner in a bong shop, we may as well reorganise the file layout to something more conventional and dispose with the Waf build system altogether.&lt;/p&gt;
&lt;p&gt;Our new repository directory structure looks like this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;valadate&lt;ul&gt;
&lt;li&gt;libvaladate&lt;/li&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;li&gt;tests&lt;ul&gt;
&lt;li&gt;libvaladate&lt;/li&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This structure is a fairly commonly used pattern in developing medium to large size projects, you essentially replicate the source tree within the tests folder. This makes it easier to locate individual tests and means your integration tests will follow the same basic pattern as the main source tree does at compile time. With smaller projects, you could just get away with a simple &lt;code&gt;tests&lt;/code&gt; directory - with the relatively small SLOC that Valadate has now it could probably all reside within a single source file! Given that we expect the project to grow significantly though, especially when we start adding complex features like BDD tests and a GUI as well as several layers of tests of tests, we should probably start with a more scalable structure.&lt;/p&gt;
&lt;p&gt;OK, now we're finally ready to start writing tests. Given that this is a Testing Framework, we're facing a potential chicken and egg situation - what framework do we use to test our framework? In this case, the solution is pretty straightforward, we have the GLib Test suite at our disposal which we can use to write the base tests that will guide the design of the framework. Once these tests all pass, we can move on to using Valadate to test itself when adding more complex testing features like Gherkin/Cucumber. Finally, we can use those features for even more complex testing such as user acceptance and integration tests for the project as a whole. The process is iterative and cascading, meaning that as features at one level are sufficiently tested they will become available for the next successive layer of tests. You could think of it like an Onion, if you like, or a series of waterfalls but my mental image at the moment is more like this:&lt;/p&gt;
&lt;p&gt;
&lt;iframe allowfullscreen="true" frameborder="0" height="315" src="//www.youtube.com/embed/eMqGdRqj1_0" width="560"&gt;&lt;/iframe&gt;
&lt;/p&gt;
&lt;p&gt;But that's just me. Use whatever metaphor you like, it's your head after all.&lt;/p&gt;
&lt;p&gt;So we begin using the basic or 'naked' (as I like to call it) &lt;a href="https://developer.gnome.org/glib/stable/glib-Testing.html"&gt;GLib Testing Framework&lt;/a&gt;. Now the GLib Testing Framework is actually pretty powerful and was originally designed according to the xUnit interface. It's fairly straightforward to use, as this example from the &lt;a href="https://wiki.gnome.org/Projects/Vala/TestSample"&gt;Gnome Vala Wiki&lt;/a&gt; shows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;add_foo_tests&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/vala/test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ref&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;add_foo_tests&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It also has the gtester and gtester-report utilities which are well integrated with existing toolchains and are able to output test results in a variety of formats.&lt;/p&gt;
&lt;p&gt;The main drawbacks of the GLib Testing Framework, and hence the need for Valadate at all, are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is not particularly Object Oriented - the base classes are all &lt;code&gt;[Compact]&lt;/code&gt; classes and do not inherit from a common Test base class. This makes extending them in Vala difficult.&lt;/li&gt;
&lt;li&gt;The test report functions need a lot of configuration to produce usable output, including several 'drivers' or shell scripts for postprocessing.&lt;/li&gt;
&lt;li&gt;It is not particularly well documented&lt;/li&gt;
&lt;li&gt;It doesn't scale very well to large projects or for Behavior Driven Design.&lt;/li&gt;
&lt;li&gt;It's verbose and difficult to read.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most of these limitations are solvable in one form or another, so it should serve as a sufficient base to get started. If we follow the principles of Test Driven Design it should become obvious when we need to build something more powerful or flexible.&lt;/p&gt;
&lt;p&gt;Which tests and features do we write first? Well, that's determined by the requirements we've gathered and how we've prioritised them. One of the many great things of having a wife who is a CTO for a foundation developing open source land tenure software is that I get to vicariously experience how she manages her team's workflow and the tools they use to do that. One of the recent tools that they have started using for project management is &lt;a href="https://waffle.io/"&gt;Waffle&lt;/a&gt;, which integrates seamlessly with GitHub Issues and Pull Requests. Waffle is the next step beyond the &lt;a href="http://bit.ly/1ZSrRA6"&gt;Trello board&lt;/a&gt; that I was using to initially gather the requirements for Valadate. Waffle allows anyone to add a feature request or file a bug to the Backlog either through the &lt;a href="https://waffle.io/chebizarro/valadate"&gt;Waffle board&lt;/a&gt; for the project or by simply creating a &lt;a href="https://github.com/chebizarro/valadate/issues/new"&gt;new issue&lt;/a&gt; on the GitHub page. The latter is the most straightforward as you don't need to log into Waffle at all.&lt;/p&gt;
&lt;p&gt;One of my wife's philosophies of Open Source is that it's not enough to just release your source code. A true Open Source project is also developed in the open, meaning that the history behind why certain design decisions were made, and by who, is recorded and all issues and pull requests are reviewed and where they meet the project's (i.e. enduser's) requirements, are fixed or merged, regardless of the source. Public repositories are, at the very least mirrors if not the working versions of the current master and branches, not just static snapshots of a final release.&lt;/p&gt;
&lt;p&gt;Taking an Open from the Start approach is also something that is essential in building a strong, diverse community of users around your product. Sarah Sharp, a long time Linux Kernel contributer, has written extensively about this on her &lt;a href="http://sarah.thesharps.us/2015/10/06/what-makes-a-good-community/"&gt;blog&lt;/a&gt;. One of the things that I'm going to take the opportunity to lock down now is a Code of Conduct for contributors. I'm not going to go into the pros and cons of having a Code of Conduct - as I don't see any cons in the first place! So, as Sarah says on her blog -&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We don’t write legal agreements without expert help. We don’t write our own open source licenses. We don’t roll our own cryptography without expert advice. We shouldn’t roll our own Code of Conduct.&lt;a href="http://sarah.thesharps.us/2016/01/25/code-of-conducts-warning-signs/"&gt;1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With that in mind, I've signed the project on to the &lt;a href="http://todogroup.org/opencodeofconduct/#Valadate/chebizarro@gmail.com"&gt;Open Code of Conduct&lt;/a&gt;, which is used by GitHub and is inspired by the codes of conduct and diversity statements of projects like Django, Python and Ubuntu. It's worth a read, even if it's your bread and butter, but here's my summary - "don't be an asshat" - and you can tweet me on that.&lt;/p&gt;
&lt;p&gt;So that's all for this post, join me again soon for Part 5 where I will outline the product roadmap for the first release and delve into when we know we've tested enough with coverage reports. Thanks for reading and please feel free to join the conversation if you have something to say!&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category><category term="CoC"></category></entry><entry><title>Hacia un framework de desarrollo guiado por pruebas para Vala - cuarta parte - Quien pone a prueba el probador?</title><link href="http://chrisdaley.biz/es/test-driven-development-in-vala-pt-4.html" rel="alternate"></link><updated>2016-02-04T16:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-02-04:es/test-driven-development-in-vala-pt-4.html</id><summary type="html">&lt;p&gt;Después de una breva pausa para trabajar en uno de mis otros proyectos (&lt;a href="http://www.last.fm/music/Calisse"&gt;un grupo de Rock 'n Roll&lt;/a&gt;) y terminar con la instalación de &lt;a href="http://jenkins.valadate.org:8080"&gt;Jenkins&lt;/a&gt;, he vuelto a trabajar en el proyecto ya oficialmente llamado &lt;a href="https://github.com/chebizarro/valadate"&gt;Valadate&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Como he mencionado antes, hubo algunos intentos iniciales de desarrollar un framework de TDD para Vala, el &lt;a href="https://github.com/yorba/valadate"&gt;Valadate&lt;/a&gt; siendo lo más extenso de ellos. Después de pensarlo bien, y un revisión de la base de código existente, decidí que la propuesta más practica seria asumir el papel de mantenedor de proyecto y refundirlo como sea necesario para cumplir los nuevos requisitos que se han sido &lt;a href="http://bit.ly/1ZSrRA6"&gt;recopilados&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Actualmente, el paquete de Valadate dispone de varias clases de utilidad para las tareas como pruebas asincrónicas y directorios temporales además de un Test Runner de la linea de comando. El proceso para escribir pruebas es crear una implementación concreta de la interfaz de Valadate Fixture con las pruebas siendo los métodos cuyos nombres empiezan con &lt;code&gt;test_&lt;/code&gt;. La prueba está compilado en un binario (una biblioteca compartida) que es ejecutado por el Test Runner. El descubrimiento de pruebas se hace mediante cargar los archivos de .vapi y .gir generado por Vala cuando el binario sea compilado. El sistema de construir es &lt;a href="https://es.wikipedia.org/wiki/Waf"&gt;Waf&lt;/a&gt;, pero para revisar el código, lo porte a autotools, un sistema de construir que me resulta más cómodo.&lt;/p&gt;
&lt;p&gt;El código se compila, pero ha sufrido un poco de pudrición, con varios avisos de deprecación, especialmente las pruebas asincrónicas. El framework si mismo es muy flaco y usar las clases de GLib Test y TestSuite para agrupar y ejecutar las pruebas que se encuentran dentro del binario. En suma no haya más de 1000 lineas de código fuente (SLOC en ingles) en el proyecto. Aunque haya algunas ideas interesantes en el código actual, he decidido que la mejor propuesta seria empezar de nuevo y integrar lo que sea útil y mandar los restos al cielo || infierno binario.&lt;/p&gt;
&lt;p&gt;Ya que hay un repositorio para Valadate armado y actualizado para ser construido con autotools, voy a utilizarlo como el &lt;code&gt;master&lt;/code&gt; de lo que vamos a derivar las varias ramas de desarrollo, siguiendo la practica amplia usada de &lt;a href="http://aprendegit.com/git-flow-la-rama-develop-y-uso-de-feature-branches/"&gt;"GitHub Flow"&lt;/a&gt;, un proceso de gestión de repositorios que encarna los principios de Integración Continua. En una palabra, se implica seis pasos discretos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Crear una rama para desarrollar una función nueva&lt;/li&gt;
&lt;li&gt;Agregar los commits a la rama&lt;/li&gt;
&lt;li&gt;Abrir peticiones de Pull&lt;/li&gt;
&lt;li&gt;Comentar y revisar el código&lt;/li&gt;
&lt;li&gt;Desplegar&lt;/li&gt;
&lt;li&gt;Unir&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;El principio fundamental (o "la única regla" como se llama el GitHub) es que la rama &lt;code&gt;master&lt;/code&gt; está siempre lista para ser desplegada - que el caso de una herramienta como Valadate implica que se puede tirar, compilar y ejecutar en cualquier momento. Así, mientras que la rama &lt;code&gt;master&lt;/code&gt; existente de Valadate no es exactamente lista para producción, está en el estado donde la Fundacion de Yorba dejo de mantenerlo. Por lo menos no da una linea de saque de donde podemos empezar y un poquito de continuidad con el proyecto original, aunque solo sea para dar crédito a los desarrolladores originales por su afán.&lt;/p&gt;
&lt;p&gt;Estamos listos para bifurcar nuestra versión nueva, que vamos a llamarla? El sistema de uso comun es el &lt;a href="http://semver.org/lang/es/"&gt;Versionamiento Semántico&lt;/a&gt; lo que sigue la convención de MAJOR.MINOR.PATCH.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;version MAJOR cuando hay cambios incompatibles a la API&lt;/li&gt;
&lt;li&gt;version MINOR cuando hay funciones nuevas agregadas en una manera compatible con versiones anteriores&lt;/li&gt;
&lt;li&gt;version PATCH cuando hay correcciones de errores compatibles con versiones anteriores&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El ultimo lanzamiento de Valadate fue 0.1.1 y no está totalmente claro si estaban siguiendo el esquema del Versionamiento Semántico. Hay distinto números de versión para las API y SO los cual es posible no vamos a usar en nuestro primer lanzamiento. Para que sea sencillo, voy a utilizar el numero de versión original como el punto de partida. Como vamos a hacer algunos cambios sustanciales que van a romperlo en completo la API de versión 0, deberíamos incrementarlo a uno. Dado que vamos a empezar desde cero, la versión MINOR se revertirá a 0 también. Así que el nombre de la rama de nuestra nueva implementación sera 1.0.0.&lt;/p&gt;
&lt;p&gt;Buenaso. Marcamos el numero!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git checkout -b version-1.0.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;El repositorio local ya tiene una rama llamada &lt;code&gt;version-1.0.0&lt;/code&gt; la que nos permite de dar un repaso general del código sin afectar la rama "desplegable" de &lt;code&gt;master&lt;/code&gt;. Ya que vamos a romper 
mas cosas que un stoner en una tienda de pipas de agua, bien podemos reorganizar la disposición de los archivo en algo más convencional y disponer con el sistema de Waf en total.&lt;/p&gt;
&lt;p&gt;La estructura nueva de nuestro repositorio ya parece así:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;valadate&lt;ul&gt;
&lt;li&gt;libvaladate&lt;/li&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;li&gt;tests&lt;ul&gt;
&lt;li&gt;libvaladate&lt;/li&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Esta estructura es un modelo bastante común para los proyectos de tamaño medio a grande, esencialmente se recrear el árbol de código fuente dentro del directorio de tests. Así se resulta más fácil encontrar las pruebas particulares y significa que las pruebas de integración van a siguir el mismo modelo básico a la hora de ser compilado. Con los proyectos más pequeños, se puede conseguir el mismo resultado con un directorio de test nomas - con las pocas lineas de código fuente que tiene Valadate es posible que se caben dentro de un archivo solo! Dado que esperamos que el proyecto se crezca considerablemente, especialmente cuando empezamos de agregar funciones complejas como pruebas de BDD y una interfaz gráfica tal como varios niveles de pruebas de pruebas, deberíamos empezar con una estructura más escalable.&lt;/p&gt;
&lt;p&gt;Dale, por fin estamos listo para empezar con las pruebas. Dado que este es un Framework de Pruebas, nos enfrenta una situación de huevo o la gallina - que framework vamos a usar para probar nuestro framework? En este caso, la solución es sencillo, tenemos el suite de GLib Test a nuestra disposición lo cual podemos utilizar para escribir las pruebas de base que van a guiar el diseño del framework. Una vez que esas pruebas se aproben, podemos pasar de usar Valadate para probar si mismo cuando se agregan nuevas funciones más complejas como Gherkin/Cucumber. Al final, podemos usar esas funciones para pruebas aun más complejas tal como las de validación de usuario y integración para el proyecto en general. El proceso es iterativo y en cascada, en el sentido que cuando las funciones de un nivel sean suficientemente probadas, serian disponibles para el nivel siguiente de pruebas. Puedes pensar que es como una cebolla, si quieres, o una serie de cascadas pero la imagen mental que tengo yo es más como esta:&lt;/p&gt;
&lt;p&gt;
&lt;iframe allowfullscreen="true" frameborder="0" height="315" src="//www.youtube.com/embed/eMqGdRqj1_0" width="560"&gt;&lt;/iframe&gt;
&lt;/p&gt;
&lt;p&gt;Pero así soy yo. Usas cualquier metáfora que quieres, al fin y al cabo es tu mente.&lt;/p&gt;
&lt;p&gt;Así empezamos utilizando el básico &lt;a href="https://developer.gnome.org/glib/stable/glib-Testing.html"&gt;framework de GLib Testing&lt;/a&gt;. Osea, de veras el Glib Testing Framework tiene mucha potencia y al primero fue diseñado según la interfaz de xUnit. Es bastante fácil usarlo, como este ejemplo del &lt;a href="https://wiki.gnome.org/Projects/Vala/TestSample"&gt;Wiki de Gnome Vala&lt;/a&gt; muestra:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;add_foo_tests&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/vala/test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ref&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;add_foo_tests&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Además, tiene las utilidades de gtester y gtester-report las cuales son integrados bien con las cadenas de herramienta existentes y son capaces de producir los resultados de las pruebas en varios formatos.&lt;/p&gt;
&lt;p&gt;Las desventajas principales del GLib Testing Framework, y por lo tanto la necesidad de Valadate en absoluto, son:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No está particularmente orientado hacia objetos - la clases de base son todas &lt;code&gt;[Compact]&lt;/code&gt; y no heredan de una clase común. Así resulta difícil extenderlas en Vala.&lt;/li&gt;
&lt;li&gt;Las funciones de los informes de pruebas necesitan ser configuradas para producir algo útil, incluso varios 'drivers' o scripts de shell para el proceso anterior.&lt;/li&gt;
&lt;li&gt;No está bien documentado&lt;/li&gt;
&lt;li&gt;No escalar bien para los proyectos grandes o para el diseño guiado por comportamiento.&lt;/li&gt;
&lt;li&gt;Es verboso y difícil de leer.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La mayoría de esas limitaciones se pueden resolver de una manera u otro, así debería bastar como un punto de partida. Si sigamos los principios de diseño guiado por pruebas debería ser obvio cuando tendremos construir algo más poderos o flexible.&lt;/p&gt;
&lt;p&gt;Cuales pruebas y funciones escribamos en primero? Pues, eso se determina mediante los requisitos que ya recompilamos y como los hemos priorizado. Una de las muchas ventajas de tener una esposa que es una CTO para un fundación que va desarrollando software libre de tenencia de la tierra es que yo puedo experimentar vicariamente como ella gestionar el flujo de trabajo de su equipo y las herramientas que usan. Una de las herramientas que recién empezaron de utilizar para la gestión de los proyectos es &lt;a href="https://waffle.io/"&gt;Waffle&lt;/a&gt;, la que integrarse bien con los asuntos de GitHub y las peticiones de Pull. Waffle es el paso más allá de la &lt;a href="http://bit.ly/1ZSrRA6"&gt;placa de Trello&lt;/a&gt; que usaba para recopilar los requisitos para Valadate. Waffle permite que cualquiera agrega una petición de funciones o mandar un resumen de error al Backlog o mediante la &lt;a href="https://waffle.io/chebizarro/valadate"&gt;placa de Waffle&lt;/a&gt; para el proyecto o por crear un &lt;a href="https://github.com/chebizarro/valadate/issues/new"&gt;nuevo asunto&lt;/a&gt; en la pagina de GitHub. El ultimo es la manera más sencilla como no hay que acceder a Waffle en absoluto.&lt;/p&gt;
&lt;p&gt;Una de las filosofías de código abierto de mi esposa es no basta lanzar el código de fuente. Un proyecto de código abierto verdadero es también desarrollado en una manera abierta - lo que implica que haya una historia registrada de todas las decisiones, porque y por quien, y todos los asuntos y peticiones de Pull sean revisados y cuando cumplan los requisitos del proyecto (es decir los del usuario) son arreglados o unidos, a pesar de la fuente. Los repositorios públicos son, por lo menos espejos sino la versión corriente del &lt;code&gt;master&lt;/code&gt; y las ramas, no solamente una instantánea estática del ultimo lanzamiento.&lt;/p&gt;
&lt;p&gt;Tomar una posición &amp;lt;&lt;Abierto desde el Principio&gt;&amp;gt; es algo esencial en levantar una comunidad fuerte y pluralista de usuarios centrada en el producto. La Sara Sharp, una colaboradora de largo plazo, ha escrito extensamente sobre este tema en su&lt;a href="http://sarah.thesharps.us/2015/10/06/what-makes-a-good-community/"&gt;blog&lt;/a&gt;. Una de las cosas que voy a tomar la oportunidad de realizar ahora es un Código de Conducta. No voy a hablar de los pros y contras de tener un Código de Conducta - no veo ningún contra! Así que, como dice la Sarah en su blog - &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;No escribimos acuerdos legales sin la ayuda de expertos. No escribimos nuestras propias licencias de código abierto. No enrollamos nuestra propia criptografía sin el consejo de expertos. No debemos enrollar nuestro propio Código de Conducta.&lt;a href="en ingles"&gt;1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Tomando esto en cuenta, he inscrito el proyecto en el &lt;a href="http://todogroup.org/opencodeofconduct/#Valadate/chebizarro@gmail.com"&gt;Open Code of Conduct&lt;/a&gt;, lo que está usado por GitHub y inspirado por los códigos de conducta y las declaraciones de la diversidad de proyectos como Django, Python y Ubuntu. Vale la pena leerlo, pero ahí va mi resumen - "no seas pelotudo" - y me puedes citar en Twitter.&lt;/p&gt;
&lt;p&gt;Dale, ya está para este post. De prontito voy a publicar la parte 5 cuando voy a trazar el roadmap del producto para el primer lanzamiento y contestar la pregunta de "cuando vamos a saber si las pruebas bastaran" con los informes de cobertura. Gracias por leer y si tienes algo de decir, por fa dilo!&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Código Abierto"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category><category term="CoC"></category></entry><entry><title>Towards a Test Driven Development Framework in Vala Part 3. DevOps - Continuous Integration with Jenkins</title><link href="http://chrisdaley.biz/test-driven-development-in-vala-pt-3.html" rel="alternate"></link><updated>2016-01-19T10:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-19:test-driven-development-in-vala-pt-3.html</id><summary type="html">&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Continuous_integration"&gt;Continuous Integration&lt;/a&gt; or CI is widely used in Test Driven Design for keeping the project's codebase tight, reducing errors and making sure there is always a working build available for deployment. It provides a means to automate the whole build and testing process, so developers can focus on writing their tests and the code that passes them. By setting up a system that builds and tests the software on its supported platforms, deployment issues can be identified early and distribution of new releases automated.&lt;/p&gt;
&lt;p&gt;Since once of the objectives of Valadate is to integrate with existing toolchains, and wanting to leverage the numerous benefits of CI for the project itself, I took a short DevOps break to set up a &lt;a href="https://jenkins-ci.org/"&gt;Jenkins&lt;/a&gt; based system on my local network. Jenkins is a widely used open source Continuous Integration server written in Java, so it can pretty much run anywhere, providing the system has enough juice. Taking this to its extreme, I decided to install it on a spare Raspberry Pi 2 I had lying around. So why Jenkins and why on a Raspberry Pi?&lt;/p&gt;
&lt;p&gt;Firstly, Jenkins is a robust and well maintained platform that is widely used. It has a plethora of plugins that integrate it tightly with Git, Docker, TAP and numerous other CI tools and protocols. It works on the master-slave model, where the master server directs the build operations of any number of slaves. A slave can be any other computer on the network that Jenkins can communicate with, either directly through SSH or with a plugin. It is highly configurable and it just works. It seemed like a good choice to start with.&lt;/p&gt;
&lt;p&gt;&lt;img alt="The Jenkins web interface" src="http://chrisdaley.biz/images/jenkins.png" /&gt;&lt;/p&gt;
&lt;p&gt;Secondly, the Raspberry Pi. One of my considerations when setting up the CI system was that the master server should be internet accessible and available 24-7. Given that when it isn't running jobs the server is mostly idle, using a full powered computer would be a waste of electricity and CO2. It occurred to me that one of my spare Rapsberry Pis could do the job, so after a quick Google to confirm that it was possible, I proceeded with the install. The one comprehensive guide I had found had suggested a lot mucking about with downloading source packages, but since it was for the previous version of Raspbian I tried &lt;em&gt;sudo apt-get install jenkins&lt;/em&gt; and whaddya know, it just worked.&lt;/p&gt;
&lt;p&gt;With the Jenkins server up and running, I added my recent &lt;a href="http://github.com/chebizarro/gherkin-vala"&gt;port of Gherkin&lt;/a&gt; as a test job and set up a machine running Fedora 23 as a slave and in 5 minutes it had checked out, compiled and run the unit tests on it and...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Build Status" src="http://chrisdaley.biz/images/passing.png" /&gt;&lt;/p&gt;
&lt;p&gt;\O/ \O/ \O/&lt;/p&gt;
&lt;p&gt;Despite being relatively low-powered, the Raspberry Pi seems up to the task, as nothing is actually being built on it. Some configuration pages take a while to load, but for ordinary usage it's quite snappy. Not only that, but you can do &lt;a href="https://www.perforce.com/blog/150910/continuous-delivery-fun-jenkins-raspberry-pi"&gt;cool things&lt;/a&gt; with it as well. &lt;/p&gt;
&lt;p&gt;Emboldened by my initial success, I moved onto setting up a Docker slave. For this setup, I revived an old server that had been mothballed, with the idea that as a build slave it doesn't need to be online all the time and with Wake On Lan (WOL) I can have Jenkins wake the server up when it needs to do a build and put it back to sleep when its done. This is still on the to-do list, but seems fairly straightforward.&lt;/p&gt;
&lt;p&gt;In this configuration, the slave is a Docker host that starts up and runs a container built from a Dockerfile in the repositories root. It is this container that runs the build, not the host, so it is possible to test your software on pretty much any platform that can be dockerized. Cool eh? So I set up an Ubuntu container and...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Build Status" src="http://chrisdaley.biz/images/failing.png" /&gt;&lt;/p&gt;
&lt;p&gt;Huh?!? I looked at the log and...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;./.libs/libgherkin3.so: undefined reference to `g_value_init_from_instance&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Dammit! In my rush to port Gherkin, I had done it on my new Fedora 23 box and hadn't actually tested it on Ubuntu at all. I checked the docs and sure enough, GLib.Value.init_from_instance() is available from GLib 2.42 on only and Ubuntu 15.04 ships with 2.40. D'oh! So now I either have to refactor the code or declare GLib 2.42 a prerequisite.&lt;/p&gt;
&lt;p&gt;This particular case is a really good example of the benefits of Continuous Integration. If I had had the Jenkins server set up before I ported the code, I would have noticed the incompatibility almost immediately and would have been able to deal with it then, rather than refactoring later.&lt;/p&gt;
&lt;p&gt;As nice as it would be to ignore the existence of other operating systems, the sad truth is that not everyone uses Linux as their primary desktop, including many people who might want to use my software. With this harsh reality in mind, I decided to set up Windows and Mac OSX slaves to test the cross platform compatibility of my projects.&lt;/p&gt;
&lt;p&gt;For the Windows slave, I set up a new Windows 7 VM in VirtualBox, running on the same server as the Docker host. For the build toolchain, I installed MinGW64 and MSYS2 and all of the necessary libraries and voila! Well, not quite voila, the MinGW linker is soooo sloooow that it took quite some time to debug but is now working just fine. The process isn't quite fully automated - I still need to manually spin it up and shut it down. There is a VirtualBox plugin to do this, but it doesn't presently support version 5. I also learned the hard way that you need to disable automatic updating for Windows, otherwise it will get stuck at the failed boot recovery screen. I am also thinking that for speed, I will cross compile the Windows binaries in a Docker container and run the tests in the Windows VM to make sure they work.&lt;/p&gt;
&lt;p&gt;Now, if you've been to any major Linux conference in the last few years, you'd be forgiven for thinking you were at WWDC with all the Apple hardware being toted about. Heck, my wife, an Open Source guru, was a long time MacBook Air user until she got a Microsoft Surface. And it's true, it is some of the coolest, most expensive hardware you can run a Linux Virtual Machine on. Don't get me wrong, I have one on my desk, I just mostly use it for email, IRC and the occasional Photoshop session (at least until Gimp gets better tablet support). Unfortunately, it's been a little neglected so it needs a bit of a clean up before it can be pressed into service, which will hopefully be by the start of next week.&lt;/p&gt;
&lt;p&gt;Along the way I also discovered that our crappy Comcast provided Cable Modem doesn't support hairpin DNS resolutions when I forwarded the Jenkins server ports. I tried to solve this by setting up dnsmasq on the Raspberry Pi but it still required manually editing the resolv.conf files on each machine. In the end I just put the Comcast Modem into bridge mode and set up a trusty old WRT-54GL running DD-WRT as the new Gateway/Router. It still has some problems with IPv6 DHCP but otherwise is running just fine.&lt;/p&gt;
&lt;p&gt;So there you have it, a working cross-platform Continuous Integration system building Vala based projects. It's live on the internet now, so you can check it out &lt;a href="http://jenkins.valadate.org:8080"&gt;here&lt;/a&gt; (Github login required).&lt;/p&gt;
&lt;p&gt;OK, now we're ready to start building Valadate! Tune in again soon for Part 4. Who tests the tester?&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category><category term="Jenkins"></category><category term="Continuous Integration"></category><category term="DevOps"></category></entry><entry><title>Hacia un framework de desarrollo guiado por pruebas para Vala - tercera parte - DevOps - Integración Continua con Jenkins</title><link href="http://chrisdaley.biz/es/test-driven-development-in-vala-pt-3.html" rel="alternate"></link><updated>2016-01-19T10:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-19:es/test-driven-development-in-vala-pt-3.html</id><summary type="html">&lt;p&gt;&lt;a href="https://es.wikipedia.org/wiki/Integraci%C3%B3n_continua"&gt;Integración Continua&lt;/a&gt; o IC está ampliamente usado en TDD para mantener la base de código de un proyecto bien ordenada, reduciendo los errores y asegurando que hay siempre ejecutables disponibles para desplegar. Proporciona medios para automatizar el proceso de compilar y probar, así que los desarrolladores se pueden enfocar en escribir pruebas y el código que las pasara. Mediante la instalación de un sistema que compila y prueba el software en las plataformás que las soporta, los problemás de despliegue pueden ser identificados temprano y la distribución de los nuevos lanzamientos automatizados.  &lt;/p&gt;
&lt;p&gt;Dado que uno de los objetivos de Valadate es integrarse en las cadenas de herramientas ya existente, y con ganas de aprovechar los beneficios numerosos para el proyecto si mismo, tome un pequeño break de &lt;a href="https://es.wikipedia.org/wiki/DevOps"&gt;DevOps&lt;/a&gt; para instalar un sistema basado en &lt;a href="https://es.wikipedia.org/wiki/Jenkins"&gt;Jenkins&lt;/a&gt; en mi red local. Jenkins es un servidor de Integración Continua de codigo abierto que está ampliamente usado. Escrito en Java, se puede ejecutar en cualquier en cualquier sistema, dado que tenga suficiente potencia. Llevándose al extremo, decidí instalarlo en un Raspberry Pi 2 que tenia por ahí. Por que Jenkins y por que en un Raspberry Pi?&lt;/p&gt;
&lt;p&gt;En primero, el Jenkins es una plataforma robusta y mantenida que está ampliamente usado. Hay una plétora de complementos que integrarse bien con Git, Docker, TAP y muchos otros herramientas y protocoles de IC. Se basa en el modelo de amo-esclavo, donde el servidor amo dirige las operaciones de compilar en cualquier numero de esclavos. Un esclavo puede ser cualquier otra computadora en la red que puede comunicarse con Jenkins, o directamente a través de SSH o con un complemento. Es fácil de configurar y sencillamente funciona. Me parecía una buena elección por empezar.&lt;/p&gt;
&lt;p&gt;&lt;img alt="La interfaz wed de Jenkins" src="http://chrisdaley.biz/images/jenkins.png" /&gt;&lt;/p&gt;
&lt;p&gt;En segundo, la Raspberry Pi. Uno de las consideraciones en armar el sistema de IC fue que el servidor amo debe ser accesible por la internet y disponible 24x7. Dado que cuando no hay tareas en marcha el servidor está más o menos desocupado, utilizando una computadora de plena potencia seria una perdida de energía y dióxido de carbono. Me di cuenta que una de las Raspberry Pi que no estaba ocupada podría hacer el trabajo, así que después de una búsqueda rápida de Google para confirmar que sea posible, seguí con la instalación. La guía más comprensiva que encontré sugirió huevadas como descargar paquetes de código fuente pero dado que esa fue para una versión previa de Raspbian, intentaba con &lt;em&gt;sudo apt-get install jenkins&lt;/em&gt; y salio nomás.&lt;/p&gt;
&lt;p&gt;Con el servidor de Jenkins ya en marcha, agregue el &lt;a href="http://github.com/chebizarro/gherkin-vala"&gt;port de Gherkin&lt;/a&gt; que recién lancé como una prueba y arme una maquina con Fedora 23 como esclavo y dentro de 5 minutos lo había hecho checkout, compilado y ejecutado las pruebas y...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Build Status" src="http://chrisdaley.biz/images/passing.png" /&gt;&lt;/p&gt;
&lt;p&gt;\O/ \O/ \O/&lt;/p&gt;
&lt;p&gt;A pesar de tener poco potencia, la Raspberry Pi parece adecuada para la tarea, como no compilar nada. Algunas de las paginas de configuración tarden un ratito en cargar pero para el uso ordinario parece rápida. No solo eso, sino puedes hacer &lt;a href="https://www.perforce.com/blog/150910/continuous-delivery-fun-jenkins-raspberry-pi"&gt;cosas chulas&lt;/a&gt; también. &lt;/p&gt;
&lt;p&gt;Animado por el éxito inicial, arme un esclavo de Docker. Para esta configuración, reanime un antiguo servidor que había sido mothballed, con la idea que como un esclavo de compilar, no necesitara estar en linea todo el tiempo y con Wake On Lan (WOL) puedo mandar que Jenkins despierte el servidor cuando necesite hacer una tarea y adormecerlo cuando se termina. Eso todavía se queda por hacer pero me parece sencillo. &lt;/p&gt;
&lt;p&gt;Con esta configuración, el esclavo es un anfitrión de Docker y se arranca y ejecutar un contenedor armado de un Dockerfile en la raíz del repositorio. Es este contenedor que ejecutar la compilación, no el anfitrión, asimismo es posible probar tu software en casi cualquier plataforma que se puede dockerize. Que guay no? Entonces, arme un contenedor de Ubuntu y...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Build Status" src="http://chrisdaley.biz/images/failing.png" /&gt;&lt;/p&gt;
&lt;p&gt;Como que? Mire el log y...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;./.libs/libgherkin3.so: undefined reference to `g_value_init_from_instance&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Maldito sea! En la prisa de portear Gherkin, lo hice en mi nuevo sistema de Fedora 23 y no lo había probado nada en Ubuntu. Comprobé los documentos y por cierto, GLib.Value.init_from_instance() está disponible a partir de la version 2.42 de GLib y el Ubuntu 15.04 solamente lleva la versión 2.40. D'oh! Así que tengo que refactorizarlo o declarar GLib 2.42 como requisito.&lt;/p&gt;
&lt;p&gt;Este caso en particular es un muy buen ejemplo de los beneficios de Integración Continua. Si tuviera el servidor de Jenkins armado antes de portear el código, me habría dado cuenta de la incompatibilidad casi de inmediato y lo habría arreglado en aquel momento, más bien que refactorizarlo más tarde. &lt;/p&gt;
&lt;p&gt;Aunque seria bonito ignorar la existencia de los otros sistemás operativos, la verdad triste es que no todo el mundo usar el Linux como su escritorio principal, incluso ya mucha gente que tal vez querría usar mi software. Conciente de esa realidad brutal, decidí armar esclavos de Windows y Mac OSX para probar la compatibilidad multiplataforma de mis proyectos. &lt;/p&gt;
&lt;p&gt;Para el esclavo de Windows, instale una nueva VM de Windows 7 en VirtualBox, ejecutando en el mismo servidor que el anfitriona de Docker. Para la cadena de herramienta, instale MingGW64 y MSYS2 y todas las bibliotecas necesarias y voila! Pues, no exactamente voila, el linker de MinGW es tan despacio que me costo bastante tiempo depurarlo pero ya funciona bien. El proceso no es totalmente automático - tengo que arrancar y apagarlo a mano. Hay un complemento de VirtualBox para hacer todo eso pero actualmente no soporta la versión 5. Tambien aprendí por las malas que hay que deshabilitar las actualizaciones automáticas para Windows, si no se trabara en la pantalla de arranca fallada. Además para darle prisa un poquito, tengo pensado compilar los binarios en un contenedor de Docker a ejecutar las pruebas el la VM de Window para asegurar que funcionan correctamente.&lt;/p&gt;
&lt;p&gt;Ahora bien, si has asistido a cualquier conferencia mayor de Linux en los últimos anos, podrías concluir que estuvieras en WWDC con todo los equipos de Apple que se veía en todas partes. Vaya, aun mi esposa, una guru de software libre, usaba un MacBook Air por mucho tiempo hasta que compró un Microsoft Surface. Y es la verdad, es unos de los equipos más chulo y caro para ejecutar una Maquina Virtual de Linux. No me entiendes mal - tengo uno en el escritorio, lo uso para email, IRC y la sesión ocasional de Photoshop (por lo menos hasta que el Gimp soporte mejor las tablas). Desafortunadamente, está un poco descuidado así que necesitara un poquito de limpieza antes de ser puesto a disposición, ojala antes del comienzo de la semana que viene.&lt;/p&gt;
&lt;p&gt;Lo largo del camino, descubrí que nuestro Modem de Cable de mierda, proporcionado por Comcast no soporta las resoluciones DNS de horquilla cuando redirigí los puertos del servidor Jenkins. Intentaba resolver eso mediante instalar dnsmásq en la Raspberry Pie pero aun así necesitaba editar a mano los archivos de resolv.conf en cada maquina. Al final, puse el Modem de Comcast en modo puente y arme un viejo pero confiable WRT-54GL con DD-WRT como el nuevo Gateway/Router. Aun tiene problemás con el DHCP de IPv6 pero por lo menos funciona bien.&lt;/p&gt;
&lt;p&gt;Entonces ya está, un sistema de Integración Continua multiplataforma compilando proyectos basados en Vala. Está en vivo en la internet ahora, así que se puede ver &lt;a href="http://jenkins.valadate.org:8080"&gt;aqui&lt;/a&gt; (se requiere login de Github).&lt;/p&gt;
&lt;p&gt;Venga, ya estamos listos para empezar a construir Valadate! Sintonice de nuevo prontito para la cuarta parte - Quien pone a prueba el probador? &lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Código Abierto"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category><category term="Jenkins"></category><category term="Integración Continua"></category><category term="DevOps"></category></entry><entry><title>Towards a Test Driven Development Framework in Vala Part 2. Requirements and System Architecture</title><link href="http://chrisdaley.biz/test-driven-development-in-vala-pt-2.html" rel="alternate"></link><updated>2016-01-13T10:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-13:test-driven-development-in-vala-pt-2.html</id><summary type="html">&lt;p&gt;Less than a week ago I &lt;a href="http://chrisdaley.biz/test-driven-development-in-vala-pt-1.html"&gt;posted&lt;/a&gt; a call for input on my proposal to build a Test Driven Development Framework for Vala and feedback has been slowly trickling in. You can see a summary &lt;a href="https://gist.github.com/chebizarro/6c949fafe1e9a2c59b26"&gt;here&lt;/a&gt; which has also been distilled into a &lt;a href="http://bit.ly/1ZSrRA6"&gt;Trello board&lt;/a&gt; which will become the Product Backlog and Product Roadmap. The list is looking fairly complete so far, so I figure I'm just about ready to close it off and work on a Release Plan. Then I can finally start writing code! Phew.&lt;/p&gt;
&lt;p&gt;The requirements gathered so far are pretty much in line with other testing frameworks, but here's a good time to review our Product Vision again and see if we're heading in the right direction. I've highlighted the parts of the statement which correspond to features so we can compare.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For Vala developers who need to test their code, &amp;lt; insert cool tool name &amp;gt; is a powerful testing framework that &lt;strong&gt;provides behavioral, functional and unit testing features&lt;/strong&gt; to help them write great Open Source software. Unlike other testing frameworks, &amp;lt; insert cool tool name &amp;gt; is &lt;strong&gt;designed especially for Vala&lt;/strong&gt; while &lt;strong&gt;integrating seamlessly into existing toolchains&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's look at that Requirements we've gathered so far and see if these features would meet this vision:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Product Backlog" src="http://chrisdaley.biz/images/requirements.png" /&gt;&lt;/p&gt;
&lt;h4&gt;provides behavioral, functional and unit testing features&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Test discovery&lt;/li&gt;
&lt;li&gt;Async tests&lt;/li&gt;
&lt;li&gt;Test Runner&lt;/li&gt;
&lt;li&gt;Support for Gherkin&lt;/li&gt;
&lt;li&gt;Asserts&lt;/li&gt;
&lt;li&gt;Test protected behavior&lt;/li&gt;
&lt;li&gt;Abstract Tests&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;designed especially for Vala&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Genie support&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;integrating seamlessly into existing toolchains&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Output TAP&lt;/li&gt;
&lt;li&gt;Compatible with gstester&lt;/li&gt;
&lt;li&gt;CLI and standalone GUI&lt;/li&gt;
&lt;li&gt;PIE binaries&lt;/li&gt;
&lt;li&gt;Integrate with CI tools like Jenkins&lt;/li&gt;
&lt;li&gt;Tests can compile and run without framework installed&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So far so good! Of course, this is an Agile project, so this list is not exhaustive or final and we can expect some features to be added and others modified or removed altogether. The important thing is that our features align with our vision. The result of this prioritization process will be the Product Roadmap and the Product Backlog, which will guide sprints and daily development efforts and inform the release schedule. Before we do that though, we need some guidance on how to break these features up into functional areas which will determine how we structure our code base and where to start writing our tests. To do this we need a System Architecture.&lt;/p&gt;
&lt;h3&gt;The System Architecture and TDD&lt;/h3&gt;
&lt;p&gt;One of the misconceptions that newcomers to TDD have is that you don't write any code until you've written a test for it. This leaves many people new to the concept scratching their heads about where to start, as even creating a simple command line application requires a certain amount of boilerplate code to be written before you can even start processing the user's input. At this point, a lot of beginners may inadvertently write reams of redundant tests, start reinventing already well tested wheels or just give up on TDD altogether. There are very few times when your code will be executing without any dependencies (if only libc) so you will almost always be coding within an existing framework, if only loosely. Most of these interactions with other frameworks should be encapsulated in integration tests which are developed in parallel with the unit tests. The tests which inform our system design are those which test its unique features. Our System Architecture defines these interactions and boundaries and gives us a basic skeleton upon which to start laying down a codebase. Once this is in place, we can start writing actual tests.&lt;/p&gt;
&lt;p&gt;With a project like this we already have the advantage of several examples of prior art, chief amongst these the &lt;a href="https://en.wikipedia.org/wiki/XUnit"&gt;xUnit&lt;/a&gt; architecture. xUnit is a loose framework which includes JUnit and NUnit which stipulates that any implementation has a common architecture as shown in the diagram below:&lt;/p&gt;
&lt;p&gt;&lt;img alt="xUnit Class Diagram" src="http://chrisdaley.biz/images/architecture.png" /&gt;&lt;/p&gt;
&lt;p&gt;From this diagram we can already begin to see how we will structure the code. At a minimum we will be creating separate files and tests for Test, TestRunner, TestSuite, TestCase, TestFixture and TestResult. Yep, tests for tests. I may have said this would get interesting... This will give us the minimum we need to set up a toolchain, create a repository and start pushing to it. Hooray, we're about to start writing code! Except that it still doesn't have a name...&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What's in a name? That which we call a rose by any other name would smell as sweet.&lt;/p&gt;
&lt;p&gt;William Shakespeare&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Thanks Bill. I'm still not 100% sold on Valadate, even though it does reflect the Product Vision of being made especially for Vala and that it's not strictly limited to unit testing. Calling it VUnit would reflect its XUnit origins, but it's not like there's any rigid API to conform to. Technically it doesn't matter at this stage of development, but I would like to avoid having to refactor the code later just to change the name. There's still some more work that can done before laying down any code, so I'll let it percolate for a day or two longer before making a firm decision. Now's a good a time as any to speak up if you feel passionately one way or the other.&lt;/p&gt;
&lt;p&gt;But at least it's got a logo! Let me know what you think...&lt;/p&gt;
&lt;p&gt;&lt;img alt="A stylized solar system seen at an oblique angle" src="http://chrisdaley.biz/images/valadate_logo.png" /&gt;&lt;/p&gt;
&lt;p&gt;The base was designed by &lt;a href="https://thenounproject.com/misirlou/"&gt;misirlou&lt;/a&gt; and I added the nice colors. It's meant to symbolize the eponymous asteroid that gives Vala its name.&lt;/p&gt;
&lt;p&gt;That's all for now, tune in again soon when I discuss the Roadmap and Backlog as well as how I set up Jenkins CI on a Raspberry Pi.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Hacia un framework de desarrollo guiado por pruebas para Vala - segunda parte - Requisitos y Arquitectura de Sistema</title><link href="http://chrisdaley.biz/es/test-driven-development-in-vala-pt-2.html" rel="alternate"></link><updated>2016-01-13T10:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-13:es/test-driven-development-in-vala-pt-2.html</id><summary type="html">&lt;p&gt;Ya hace menos de una semana desde que lancé un &lt;a href="http://chrisdaley.biz/test-driven-development-in-vala-pt-1.html"&gt;post&lt;/a&gt; pidiendo input a mi propuesta de armar un framework de desarrollo guiado por pruebas para Vala y las reacciones han empezado de llegar. Se puede ver un resumen &lt;a href="https://gist.github.com/chebizarro/6c949fafe1e9a2c59b26"&gt;aquí&lt;/a&gt; lo que ha sido destilado en una &lt;a href="http://bit.ly/1ZSrRA6"&gt;placa de Trello&lt;/a&gt; lo que se convertirá en el Product Backlog y el Product Roadmap. La lista me parece más o menos completa hasta ya así que pienso que está al punto de cerrarse y elaborar un Release Plan. Por fin! Puedo empezar a escribir código. Uf!&lt;/p&gt;
&lt;p&gt;Los requisitos recopilados hasta ahora son prácticamente iguales con los otros frameworks de pruebas pero este es una buena hora para revisar nuestra Visión de Producto para ver si nuestro rumbo es correcto. He destacado las partes de la declaración que corresponden con características para que podamos compararlas.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Para los desarrolladores de Vala que necesitan probar su código, &amp;lt; insertar el chulo nombre de herramienta &amp;gt; es un framework de pruebas de gran potencia que &lt;strong&gt;proporciona funciones de pruebas de las características de comportamiento, funcionales y  unitarias&lt;/strong&gt; para ayudarles a escribir gran software de código abierto. La diferencia con los otros frameworks de prueba y &amp;lt; insertar el chulo nombre de herramienta &amp;gt; es que está &lt;strong&gt;diseñado especialmente para Vala&lt;/strong&gt;, y &lt;strong&gt;integra perfectamente en las cadenas de herramientas ya existentes&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Echamos un vistazo a los requisitos que hemos recopilado hasta ya y averiguamos si esas características se caben con esa visión. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Product Backlog" src="http://chrisdaley.biz/images/requirements.png" /&gt;&lt;/p&gt;
&lt;h4&gt;proporciona funciones de pruebas de las características de comportamiento, funcionales y  unitarias&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Descubrimiento de pruebas&lt;/li&gt;
&lt;li&gt;Pruebas asincrónicas&lt;/li&gt;
&lt;li&gt;Test Runner&lt;/li&gt;
&lt;li&gt;Apoya Gherkin&lt;/li&gt;
&lt;li&gt;Afirmas&lt;/li&gt;
&lt;li&gt;Probar comportamiento protegido&lt;/li&gt;
&lt;li&gt;Pruebas abstractas&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;diseñado especialmente para Vala&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Apoya Genie&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;integra perfectamente en las cadenas de herramientas ya existentes&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Emisión de TAP&lt;/li&gt;
&lt;li&gt;Compatible con gstester&lt;/li&gt;
&lt;li&gt;ILC y IGU autónoma&lt;/li&gt;
&lt;li&gt;binarios PIE&lt;/li&gt;
&lt;li&gt;Integrar con herramientas de integración continua como Jenkins&lt;/li&gt;
&lt;li&gt;Las pruebas pueden ser compilados y ejecutado si tener el framework instalado&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hasta aquí todo bien! Por supuesto, este es un proyecto Ágil, así que está lista no es comprensiva ni final y se puede suponer que otras características se añadieren mientras que otras sean modificadas o quitadas completamente. La cosa más importante es que las características se alinea con nuestra visión. El resultado de este proceso de priorización sera el Product Roadmap y el Product Backlog, los cuales guían los sprints y los esfuerzos diarios de desarrollo y informen el programa de lanzamiento. Ante todo eso, necesitamos dirección en como vamos a dividir esas características en áreas funcionales lo que determina como vamos a estructurar nuestra base de código y donde podemos empezar escribiendo pruebas. Para esto, se necesita una arquitectura de sistema. &lt;/p&gt;
&lt;h3&gt;La arquitectura de sistema y TDD&lt;/h3&gt;
&lt;p&gt;Uno de los conceptos erróneos que tienen los novatos a TDD es que no escribes nada hasta que hay una prueba. Eso confunde a mucha gente y las deja sin saber donde empezar, como una aplicación sencilla de la linea de comando requiere una cierta cantidad de código repetitivo antes de procesar el input del usuario. Desde este punto, muchos novatos escribirían montones de pruebas redundantes o inventan ruedas ya bien probadas de nuevo o renuncian TDD por completo. Hay pocas veces cuando tu código sera ejecutando sin dependencias (si solo libc) pues siempre estas escribiendo código dentro de un framework existente, si no aproximadamente. La mayoría de estas interacciones con otros frameworks debería ser encapsulado en las pruebas de integración, las que son desarrollada en paralelo con las pruebas unitarias. Las pruebas que informen nuestro diseño de sistema son las que prueban sus características únicas. Nuestra arquitectura de sistema define esas interacciones y limites y nos da un esqueleto básico para empezar a escribir nuestra base de código. Una vez que esta hecha, podemos empezar a escribir las pruebas concretas que nos van a guiar el diseño.&lt;/p&gt;
&lt;p&gt;Con un proyecto como este tenemos la ventaja de unas muestras de la técnica anterior, la arquitectura de &lt;a href="https://es.wikipedia.org/wiki/XUnit"&gt;xUnit&lt;/a&gt; siendo la mayor entre ellas. xUnit es un framework flojo que incluye JUnit y Nunit y estipula que cualquier implementación tenga una arquitectura común, como se puede ver en el diagrama abajo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Diagrama de clases de xUnit" src="http://chrisdaley.biz/images/architecture.png" /&gt;&lt;/p&gt;
&lt;p&gt;De este diagrama podemos aun ver como vamos a estructurar el código. Como mínimo, vamos a crear archivos y pruebas distintos para Test, TestRunner, TestSuite, TestCase, TestFixture and TestResult. Si, pruebas para pruebas. Hubiera dicho que esto resultaría interesante... Este nos van a dar el mínimo que necesitamos para armar una cadena de herramientas y crear un repositorio de código. Enhorabuena, estamos al punto de empezar! Salvo que todavía no tiene nombre... &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;¿Qué tiene un nombre? Lo que llamamos rosa olería tan fragante con cualquier otro nombre.&lt;/p&gt;
&lt;p&gt;William Shakespeare&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Gracias Guili. Todavía no estoy totalmente entusiasmado con el nombre de Valadate, aunque refleja la Vision de Producto de ser diseñado especialmente para Vala y que no está solamente para las pruebas unitarias. Llamarle VUnit reflejara su procedencia de xUnit pero no es como si hubiera una API rígida para conformarse. Técnicamente en este etapa del desarrollo, no importa nada sino que me gustaría evitar los cambios innecesarios más tarde. Todavía se queda más trabajo antes de empezar escribir código, así que voy a dejarlo filtrarse por una dia o dos antes de tomar una decisión firma. Pues bien, ya es la hora de decir algo si te sientes apasionado de una u otra forma.&lt;/p&gt;
&lt;p&gt;Pero por lo menos tiene un logotipo! Dime lo que piensas...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Un sistema solar estilizado visto por un ángulo oblicuo" src="http://chrisdaley.biz/images/valadate_logo.png" /&gt;&lt;/p&gt;
&lt;p&gt;La base fue diseñado por &lt;a href="https://thenounproject.com/misirlou/"&gt;misirlou&lt;/a&gt; y agregue los colores chulos. La idea es que simboliza el asteroide epónimo que da el Vala su nombre.&lt;/p&gt;
&lt;p&gt;Pues ya está, vuelva a sintonizar prontito cuando voy a hablar de los Roadmap y Backlog además como instale Jenkina CI en un Raspberry Pi.&lt;/p&gt;</summary><category term="Vala"></category><category term="Código Abierto"></category><category term="Programación"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Farewell oh Thin White Duke - a tribute to David Bowie in Vala</title><link href="http://chrisdaley.biz/farewell-duke.html" rel="alternate"></link><updated>2016-01-11T17:00:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-11:farewell-duke.html</id><summary type="html">&lt;p&gt;I was looking at the asteroid 131 Vala, the origin of the programming language's name, on the &lt;a href="http://ssd.jpl.nasa.gov/sbdb.cgi?sstr=131;cad=1;old=0;orb=1;cov=0;log=0#orb"&gt;JPL Small Object Database&lt;/a&gt; when I heard the sad news of David Bowie's passing. Like many of my age, I grew up not knowing of a world without space travel, the threat of nuclear war or the Thin White Duke. No other artist captured that sense of both wonder and fear of a species walking a tight rope towards its destiny. Would we stumble and fall into oblivion or would we make it to the stars? Were all our heros like Major Tom? Brittle and flawed yet compellingly corageous.  &lt;/p&gt;
&lt;p&gt;I was thinking these things and more while browsing the JPL website and I noticed that the venerable old Orbit Viewer applet was no longer working. I wanted to watch some celestial bodies move that morning to the sounds of David Bowie so I downloaded the applet source and ported it to Vala. For the music, I added a small gstreamer player that loads and plays a midi file from &lt;a href="http://www.midiworld.com/files/1018/"&gt;midiworld.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
&lt;iframe allowfullscreen="true" frameborder="0" height="315" src="//www.youtube.com/embed/4lQcdikEdJU" width="560"&gt;&lt;/iframe&gt;
&lt;/p&gt;
&lt;p&gt;Porting Java code to Vala is relatively easy, especially when it is older code and doesn't have too many of the odd little workarounds that have crept into the language over the years. The quickest part was the library of functions for calculating the orbits, as this is pretty much pure math. The trickiest bit was the interface, which I recreated in Glade and the drawing routines for animating the whole thing. I have been working on a port of the Box2D physics engine, so I have already solved most of these problems before. The end result you see above.&lt;/p&gt;
&lt;p&gt;It still needs some work before it's complete - only the play button works and there's no way to adjust the viewport yet, but these are fairly trivial to implement. If anyone is interested in the code, I'll post a link to a Github repo - both the physics and animation routines are particularly interesting if you're starting out, even with the lack of comments.&lt;/p&gt;
&lt;p&gt;Thanks for watching, and thanks Starman, for all those Golden Years...&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="JPL"></category><category term="David Bowie"></category></entry><entry><title>Adiós Thin White Duke - un tributo a David Bowie en Vala</title><link href="http://chrisdaley.biz/es/farewell-duke.html" rel="alternate"></link><updated>2016-01-11T17:00:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-11:es/farewell-duke.html</id><summary type="html">&lt;p&gt;Estaba mirando el asteroide 131 Vala, lo que dio su nombre al lenguaje de programación, en el &lt;a href="http://ssd.jpl.nasa.gov/sbdb.cgi?sstr=131;cad=1;old=0;orb=1;cov=0;log=0#orb"&gt;JPL Small Object Database&lt;/a&gt;  cuando me llego la noticia triste del fallecimiento de el David Bowie. Como muchos de mi edad, crecía sin saber nada de un mundo sin viaje espacial, el amenazo de guerra nuclear o el Thin White Duke. No había otro artista capaz de captar aquel sentido de asombro y miedo de una especie caminando en la cuerda floja hacia su destino. Podríamos tropezar y caer en el olvido o alcanzaremos las estrellas? Eran todos los héroes como el Major Tom? Frágil y imperfecto, sin embargo con coraje cautivador.&lt;/p&gt;
&lt;p&gt;Estuve pensando en esas cosas cuando estaba mirando el website de JPL y me di cuenta que el venerable Orbit Viewer applet ya no estaba funcionando. Yo querría ver unos cuerpos celestes moverse esa mañana con una banda sonora de David Bowie así que descargue el código fuente del applet y lo porte a Vala. Para la musica, agregue un pequeño reproductor de gstreamer que carga y toca un archivo Midi de &lt;a href="http://www.midiworld.com/files/1018/"&gt;midiworld.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
&lt;iframe allowfullscreen="true" frameborder="0" height="315" src="//www.youtube.com/embed/4lQcdikEdJU" width="560"&gt;&lt;/iframe&gt;
&lt;/p&gt;
&lt;p&gt;Portear código de Java a Vala es relativamente fácil, especialmente cuando el código es más viejo y no tiene muchos de los trucos raros que se han introducido en el lenguaje tras tantos años. La parte más rápida de portear fue la biblioteca de funciones para calcular las orbitas, ya que esto es mas o menos pura matemática. La parte mas complicada fue la interfaz, la que creé de nuevo en Glade y las rutinas de dibujar para animar todo. Estaba trabajando en un port del motor de física Box2D, así que he resuelto muchos de esos problemas antes. El resultado final se ve arriba.&lt;/p&gt;
&lt;p&gt;Todavía le falta un poquito de trabajo antes de ser completo - solamente el buton de reproducción funcionar y aun no hay forma de ajustar el puerto de vista - pero esos son fáciles de implementar. Si le interesa a alguien, pondré todo en un repositorio de Github - tanto las rutinas de la física y la animación son bien interesante para principiantes aún con la falta de comentarios. &lt;/p&gt;
&lt;p&gt;Pues bien, gracias por mirar y gracias a ti Starman, por todos los años dorados...&lt;/p&gt;</summary><category term="Vala"></category><category term="Código Abierto"></category><category term="JPL"></category><category term="David Bowie"></category></entry><entry><title>Towards a Test Driven Development Framework in Vala Part 1.</title><link href="http://chrisdaley.biz/test-driven-development-in-vala-pt-1.html" rel="alternate"></link><updated>2016-01-08T10:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-08:test-driven-development-in-vala-pt-1.html</id><summary type="html">&lt;p&gt;I first came across &lt;a href="https://wiki.gnome.org/Projects/Vala"&gt;Vala&lt;/a&gt; when scoping out the possibility of updating a venerable old Open Source program from GTK+2 to GTK+3. I wasn't quite sure what to make of Vala at first - it was an Object Oriented Programming language based on the GObject type system that used C as an intermediary language for the gcc compiler. I looked through a bunch of the samples, and was struck by the elegance and parsimony of the syntax and how instantly understandable it was from my familiarity with Java and C#. I played with a few example apps and I was surprised at how much fun it was to use as well. It was GObject without the endless reams of boilerplate code. Properties actually made sense now and using signals is a snap. IDE support was about as good as any other language, especially in Geany, my tool of choice. I was hooked.&lt;/p&gt;
&lt;p&gt;There was only one problem. I'm a big fan of &lt;a href="https://en.wikipedia.org/wiki/Test-driven_development"&gt;TDD&lt;/a&gt; and &lt;a href="https://en.wikipedia.org/wiki/Behavior-driven_development"&gt;BDD&lt;/a&gt; and after many hours of intense Google-Fu, I was able to find precious little on the topic in regards to Vala. What &lt;a href="https://esite.ch/2012/06/writing-tests-for-vala/"&gt;there was&lt;/a&gt; boiled down to using the GLib Test library and a nice little adapter class to group individual test cases into a test suite. The end result was run through &lt;code&gt;gtester&lt;/code&gt; on the command line, usually as part of a toolchain like Autotools. This was straightforward enough for simple applications with limited user interactions, but it doesn't really scale for BDD. Some work had been done on a framework called &lt;a href="https://github.com/yorba/valadate"&gt;Valadate&lt;/a&gt; but it was abandoned by its maintainers a few years ago. This was a real blocker for me going forward. My philosophy is that you can occasionally write great software in moments of furious creativity but it takes boring old testing to consistently produce good software. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Feel the hate flow throw you" src="http://chrisdaley.biz/images/unit-tests-dv.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Feel the hate flow throw you&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The thing with Free and Open Source Software is that it's only free at the cashier. Once you get it home you have to pay an ongoing maintenance cost in time if you want to keep using it. That time could be spent making minor contributions like filing bug reports through to helping new users in forums or translating apps all the way to implementing features yourself. I see real potential in Vala but I feel that it's usability is being hampered by this missing feature. The developers of the language have given the world a great gift and their time is better spent maintaining it. The current solution is &lt;em&gt;mostly&lt;/em&gt; good enough, but generates a lot of extra code to be maintained and has no support for BDD. "Somebody should do something about it" is a phrase that makes me groan whenever I hear it, because I usually think that that someone should be the person saying it. Well, someone should do something about it.&lt;/p&gt;
&lt;p&gt;So this blog post is an effort to get the ball rolling on that something. Although I have some free time now, it's not an endless wellspring. I also don't want to start a vaporware or abandonedware project that gets added to the list of good ideas people had at one point in time. I would like to build something that is sustainable, that evolves with its users and that could be easily passed on to other maintainers should I no longer have enough time to devote to it. I imagine this has been the manifesto of a thousand failed Open Source projects, but it's better than nothing, so here goes...&lt;/p&gt;
&lt;h3&gt;Getting the ball rolling&lt;/h3&gt;
&lt;p&gt;Since this a project to bring TDD and BDD to Vala, I would like to use Agile techniques to plan and develop it. The first steps in this case are setting up a Product Vision and Requirements Gathering. I'll take a stab at the first one (quoted because VISION STATEMENT).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For Vala developers who need to test their code, &amp;lt; insert cool tool name &amp;gt; is a powerful testing framework that provides behavioral, functional and unit testing features to help them write great Open Source software. Unlike other testing frameworks, &amp;lt; insert cool tool name &amp;gt; is designed especially for Vala while integrating seamlessly into existing toolchains.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I guess that makes me the Product Owner as well. I don't really care what it's called, Valadate is as good as any but I'm open to suggestions. If there are enough ideas we might have a poll.&lt;/p&gt;
&lt;p&gt;The next step will be the Requirements Gathering, one I have a number of ideas about already but I would really like to hear from the potential end users. I've started a Trello Board to that effect and if you would like to suggest a feature or comment on one that's already there, &lt;a href="http://bit.ly/1ZSrRA6"&gt;head on over&lt;/a&gt; and make yourself heard. If that's not your medium, you can ping me on &lt;a href="http://twitter.com/chebizarro"&gt;Twitter&lt;/a&gt; or hit me up on the Vala IRC channel (irc.gimp.org #vala), as &lt;code&gt;bizarro&lt;/code&gt;. A tool like this will live or die on its fitness for purpose, so please don't hold back.&lt;/p&gt;
&lt;p&gt;That's all for now, in the next post I'll summarize the requirements that have been gathered so far and lay out the options for the system architecture as well as a provisional schedule for the first release. Thanks for tuning in and don't forget to join the conversation if you have something to add.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Hacia un framework de desarrollo guiado por pruebas para Vala - primera parte</title><link href="http://chrisdaley.biz/es/test-driven-development-in-vala-pt-1.html" rel="alternate"></link><updated>2016-01-08T10:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-08:es/test-driven-development-in-vala-pt-1.html</id><summary type="html">&lt;p&gt;Encontre &lt;a href="https://wiki.gnome.org/Projects/Vala"&gt;Vala&lt;/a&gt; por la primera vez cuando estaba averiguando la posibilidad de portear un viejo programa de código abierto desde GTK + 2 a GTK + 3. Yo no estaba muy seguro de qué hacer con Vala en aquel momento - era un lenguaje de programación orientado a objetos basado en el sistema de objetos de GObject y utilizaba C como el lenguaje intermediario con el compilador de gcc. Después de leer un montón de muestras, me llamó la atención la elegancia y parsimonia de la sintaxis y cómo fue comprensible de inmediato por mi familiaridad con Java y C #. Jugué con algunas aplicaciones de ejemplo y me sorprendió tal divertido fue utilizarlo también. Era GObject sin las interminables resmas de código repetitivo. Propiedades ya tenía sentido y el uso de señales resultaba mojo de pavo. Fue soportado por los ambientes de desarrollo integrado (IDE) tal como cualquier otro lenguaje, especialmente por Geany, mi herramienta preferida. Me enganché.&lt;/p&gt;
&lt;p&gt;Había un problema solamente. Soy un gran fan de &lt;a href="https://es.wikipedia.org/wiki/Desarrollo_guiado_por_pruebas"&gt;desarrollo guiado por pruebas&lt;/a&gt; o TDD (por sus siglas en ingles)  y después de muchas horas de intensa Google-Fu, encontré muy poco sobre el tema en respecto al Vala. Lo que &lt;a href="https://esite.ch/2012/06/writing-tests-for-vala/"&gt;hubo&lt;/a&gt; fue básicamente utilizar las funciones de prueba de la biblioteca GLib y una pequeña clase adaptador para agrupar los casos de prueba particulares en un conjunto de pruebas. El resultado final se llevó a cabo a través de &lt;code&gt;gtester&lt;/code&gt; por la línea de comandos, en general como parte de una cadena de herramientas como Autotools. Esto bastaba para aplicaciones sencillas con interacciones limitadas con el usario, pero en realidad no escala para el &lt;a href="https://es.wikipedia.org/wiki/Desarrollo_guiado_por_comportamiento"&gt;desarrollo guiado por comportamiento&lt;/a&gt; (BDD en ingles). Alguien había desarrollado un framework llamado &lt;a href="https://github.com/yorba/valadate"&gt;Valadate&lt;/a&gt; pero esto fue abandonada por sus mantenedores ya hace unos años. Esto fue un verdadero bloqueo para mí. La filosofía mía es que de vez en cuando se puede escribir gran software en los momentos furiosos de creatividad pero se precisan pruebas aburridas para producir software de calidad consistentemente.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Su falta de preubas de unidad me resulta molesta" src="http://chrisdaley.biz/images/unit-tests-dv.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;La trampa con el software libre es que solamente no cuesta nada en el cajero. Una vez que llegues a casa, tienes que pagar el costo de mantenimiento en tiempo si quieres seguir utilizándolo. Ese tiempo podría ser gastado en hacer contribuciones menores, como la presentación de informes de errores o dar ayudar a los nuevos usuarios en los foros o la traducción de aplicaciones hasta agregando y desarrollando funciones neuvas. Yo veo mucha potencia en Vala pero siento que esta falta le debilita mucho. Los desarrolladores del lenguaje han dado un gran regalo al mundo y su tiempo sería mejor ocupado en mantenerlo. La solución que ya existe es &lt;em&gt;casi&lt;/em&gt; suficiente, pero genera una gran cantidad de código para mantener y no hay soporte para BDD. "Alguien debería hacer algo" es una frase que me molesta mucho al escuchar, porque creo que ese alguien debería ser la persona que la dijo. Bueno, alguien debería hacer algo...&lt;/p&gt;
&lt;p&gt;Así que esta entrada del blog es un esfuerzo para tomar la iniciativa. Aunque en este momento tengo un poquito de tiempo libre, eso no var a ser el caso por siempre. Asimismo, no quiero empezar un proyecto vaporware o abandonadoware que sería agregado a la lista de buenas ideas que alguien tenía. Me gustaría construir algo que sea sostenible, que evolucione con sus usuarios y que podría ser traspasado a otros mantenedores si no tendría tiempo suficiente para dedicarme an ello. Me imagino que esto ha sido el manifiesto de miles de proyectos de código abierto ya fallados, pero es mejor que nada - así que hay va ...&lt;/p&gt;
&lt;h3&gt;Tomar la iniciativa&lt;/h3&gt;
&lt;p&gt;Dado que el objetivo del proyecto es capacitar Vala con TDD y BDD, me gustaría utilizar las técnicas de Agile para planificar y desarrollarlo. En este caso, los primeros pasos serían la creación de una visión de producto y la recopilación de los requisitos. Voy a tomar el primer paso (citado porque VISIÓN DE PRODUCTO).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Para los desarrolladores de Vala que necesitan probar su código, &amp;lt; insertar el chulo nombre de herramienta &amp;gt; es un framework de pruebas de gran potencia que proporciona funciones de pruebas de las características de comportamiento, funcionales y  unitarias para ayudarles a escribir gran software de código abierto. La diferencia con los otros frameworks de prueba y &amp;lt; insertar el chulo nombre de herramienta &amp;gt; es que está diseñado especialmente para Vala, y integra perfectamente en las cadenas de herramientas ya existentes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Supongo me toca a mi ser el propietario del producto también. De veras, no me importa cómo sera llamado - Valadate es suficiente bueno tal como cualquiera, pero estoy abierto a sugerencias. Si hay suficientes ideas siempre podemos tener una encuesta.&lt;/p&gt;
&lt;p&gt;El siguiente paso será la recopilación de requisitos, lo que ya tengo algunas ideas, pero me gustaría saber lo que los usuarios potenciales piensan. Por eso he armado una pizarra Trello y si deseas sugerir una función o comentar sobre una que ya existe, &lt;a href="http://bit.ly/1ZSrRA6"&gt;haz clik aquí&lt;/a&gt; y hazte oír. Si eso no es su medio preferido, me puedes pingear en &lt;a href="http://twitter.com/chebizarro"&gt;Twitter&lt;/a&gt; o en el canal de IRC de Vala (irc.gimp.org #vala), apodo: &lt;code&gt;bizarro&lt;/code&gt;. Una herramienta como esta va a vivir o morir debido a su aptitud para el uso, así que no te callas por favor!&lt;/p&gt;
&lt;p&gt;Ya está - en el próximo post voy a resumir los requisitos que habría recopilado y poner en la mesa las opciones para la arquitectura del sistema además de elaborar un calendario provisional para la primera versión. Gracias por escuchar y no olvides de unirse a la conversación si tienes algo que decir.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Código Abierto"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>An easier way to write Python plugins for Dia</title><link href="http://chrisdaley.biz/easy-python-for-dia.html" rel="alternate"></link><updated>2016-01-07T10:00:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-07:easy-python-for-dia.html</id><summary type="html">&lt;p&gt;&lt;a href="https://wiki.gnome.org/action/show/Apps/Dia"&gt;Dia&lt;/a&gt; is a free and open source diagram creation program that runs on the main dekstop platforms. It's getting a bit long in the tooth, but its still a great tool. It's very easy to extend with plugins written in Python to add new features but the actual process of writing those plugins is a little bit more complicated.&lt;/p&gt;
&lt;p&gt;Firstly, the Python API is hard to find &lt;a href="https://projects-old.gnome.org/dia/pydia.html"&gt;online&lt;/a&gt;. You can generate a diagram of the API from within Dia itself from the Help menu, but this doesn't give you a whole lot of information and the format is a little incovenient. The API can be a little tricky to navigate, and I'll share some tips on that in a later post, but the biggest problem lies in testing the plugins that you write. Dia loads all of its plugins at startup and they can't be modified during runtime which makes testing and debugging a laborious process. It's possible to write and test the parts of your plugin that don't depend on Dia separately but once you start interacting with the UI it all starts to get bogged down again.&lt;/p&gt;
&lt;p&gt;&lt;img alt="My what a big API you have!" src="http://chrisdaley.biz/images/dia-python-api.png" /&gt;&lt;/p&gt;
&lt;p&gt;Frustrated by this and wanting to develop a plugin using Test Driven Development (TDD) techniques, I wrote a small Python module that mocks the Dia API. This way you can write and test the vast majority of your plugin without having to run Dia at all! There are some limitations - any interactions with the UI for example have to be done in Dia either manually or with an automation framework, and you can't generate usable diagrams from it. It should, however, reduce the amount of time and bugs it takes to get your plugin up and running. Don't forget to Open Source it and share it with the world!&lt;/p&gt;
&lt;p&gt;If this is something you might find useful, you can check it out &lt;a href="https://github.com/chebizarro/dia-test"&gt;here&lt;/a&gt;. I originally developed it to meet the needs of a particular project I was working on at the time so there are some parts that may not be fully implemented, but I'm happy to take bug reports and pull requests. &lt;/p&gt;
&lt;p&gt;Installation is easy:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python setup.py install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;There is no practical difference in how you write your code and any existing plugin can use the module without modification. When the plugin runs outside of Dia, it loads the mock module, when it is run inside Dia, it loads the real one.&lt;/p&gt;
&lt;p&gt;Now you're all set up to start writing plugins for Dia the easy way!&lt;/p&gt;</summary><category term="Dia"></category><category term="Python"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>La manera más fácil de escribir complementos para Dia en Python.</title><link href="http://chrisdaley.biz/es/easy-python-for-dia.html" rel="alternate"></link><updated>2016-01-07T10:00:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-07:es/easy-python-for-dia.html</id><summary type="html">&lt;p&gt;&lt;a href="https://wiki.gnome.org/action/show/Apps/Dia"&gt;Dia&lt;/a&gt; es software libre para la creación de diagramas libre y es multiplataforma. Ya está un poquito viejo, pero siga siendo una gran herramienta. Es muy fácil agregarle funciones nuevas con complementos (plugins) desarrollados en Python pero el proceso mismo de escribir esos complementos es un poco más complicado.&lt;/p&gt;
&lt;p&gt;En primero, la interfaz de programación de aplicaciones (API) de Dia para Python es difícil de encontrar en  &lt;a href="https://projects-old.gnome.org/dia/pydia.html"&gt;línea&lt;/a&gt;. Siempre puedes generar un diagrama de la API desde adentro de Dia mismo pero ese no te daría mucha información y el formato es un poco inconveniente. La API puede ser un poquito difícil de navegar y voy a compartir algunos trucos sobre ese tema en un post más adelante pero el problema más grande se yace en probando los complementos que escribes. Dia carga todos los complementos al inicio y no se pueden modificar durante la ejecución del programa, así que el proceso de probar y depurar resulta laborioso. Es posible escribir y probar las piezas de tu complemento que no dependen en Dia aparte pero una vez que comiences la interacción con la interfaz, se atasca de nuevo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Vaya API grande!" src="http://chrisdaley.biz/images/dia-python-api.png" /&gt;&lt;/p&gt;
&lt;p&gt;Frustrado por eso y deseando desarrollar un complemento siguiendo las técnicas de desarrollo guiado por pruebas (TDD), escribí un pequeño modulo de Python que simular la API de Dia. Así que puedes escribir y probar la gran mayoría de tu complemento sin tener que ejecutar Dia en absoluto! Hay limitaciones - por ejemplo cualquiera interacción con la interfaz tiene que ser hecho dentro de Dia, o a mano o con un automation framework y no se puede generar diagramas útiles. Sin embargo, debería reducir la cantidad de tiempo y bugs que cueste poner en marcha tu complemento. No olvides de darle una licencia de software libre y compartirlo con el mundo! &lt;/p&gt;
&lt;p&gt;Si eso es algo que te serviría, puedes darle un vistazo &lt;a href="https://github.com/chebizarro/dia-test"&gt;ahi&lt;/a&gt;. Originalmente, lo desarrolle para satisfacer las necesidades de un proyecto determinado en lo que estaba trabajando asi que hay unas partes que no están completas pero estoy dispuesto de tomar avisos de bugs y pull requests. &lt;/p&gt;
&lt;p&gt;Es fácil instalar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;$ python setup.py install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;No hay ninguna diferencia en la manera de escribir tu código y cualquier complemento existente puede usar el modulo sin ser modificado. Cuando el complemento se ejecuta fuera de Dia, se carga el modulo de simulación, cuando se ejecuta dentro de Dia, se carga lo verdadero.&lt;/p&gt;
&lt;p&gt;Ya estas listo para empezar de escribir complementos para Dia en la manera mas fácil!&lt;/p&gt;</summary><category term="Dia"></category><category term="Python"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category><category term="Software Libre"></category></entry><entry><title>Gherkin for Vala</title><link href="http://chrisdaley.biz/gherkin-for-vala.html" rel="alternate"></link><updated>2016-01-04T20:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-04:gherkin-for-vala.html</id><summary type="html">&lt;p&gt;I've had some spare time recently to work on some pet projects and get them into a decent enough shape that they could be subjected to the withering gaze of the Panopticon. One in particular is a port of the Gherkin language to Vala. So what is Gherkin exactly and why should you care?&lt;/p&gt;
&lt;p&gt;From the &lt;a href="https://github.com/cucumber/cucumber/wiki/Gherkin"&gt;Gherkin wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gherkin is the language that &lt;a href="https://cucumber.io/"&gt;Cucumber&lt;/a&gt; understands. It is a Business Readable, Domain Specific Language that lets you describe software’s behaviour without detailing how that behaviour is implemented.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Gherkin is available for a host of languages and is tightly integrated into JUnit for example. Its syntax is pretty straightforward and designed to be intelligible by non-technical people:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  Feature: Some terse yet descriptive text of what is desired
  Textual description of the business value of this feature
  Business rules that govern the scope of the feature
   Any additional information that will make the feature easier to understand

   Scenario: Some determinable business situation
     Given some precondition
       And some other precondition
      When some action by the actor
       And some other action
       And yet another action
      Then some testable outcome is achieved
       And something else we can check happens too

   Scenario: A different situation
       ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Gherkin parser for Vala, which you can get &lt;a href="https://github.com/chebizarro/gherkin-vala"&gt;here&lt;/a&gt; reads in Feature files and builds a tree of elements that can then either be manipulated directly or output as JSON.&lt;/p&gt;
&lt;p&gt;The parser by itself is not tremendously useful, but is one of the building blocks for a comprehensive testing framework for Vala and by extension, GObject that I am presently scoping. If this is something you're interested in, and I assume it is since you've read this far, then I'd encourage you to join the conversation.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Welcome Gnome</title><link href="http://chrisdaley.biz/welcome-gnome.html" rel="alternate"></link><updated>2016-01-01T20:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-01:welcome-gnome.html</id><summary type="html">&lt;p&gt;I don't recall when the first time I ever used the Gnome Desktop was, but it must have been around the turn of the century. I had first used Linux in 1997 when I installed it on a Power Mac out of frustration with the severely underpowered Mac OS 7.5. That install didn't stick around, as the only useful program I could find was the Gimp and the X11 Desktop left a lot to be desired in terms of user friendliness. Moving on from one employer to another, I used a variety of Desktop Managers over the next couple of years whilst working as a GIS analyst and programmer. CDE was the default for our X Terminals, although I liked to fool around with the SGI Indy's IRIX, which looked like it might be going somewhere different in user interfaces. That, and the Indy was five times faster than anything else in the lab. My main desktop was still a Mac and I ended up buying one of the super slick Powerbook Lombards before I knew what it's name actually meant. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Jurassic Park Security System" src="http://chrisdaley.biz/images/jurassic-system.png" title="Um, sudo get me out of here?" /&gt;&lt;/p&gt;
&lt;p&gt;It wouldn't be until I landed in non-profit land that I ended up using Linux and the Gnome Desktop on a daily basis. I found Gnome at the time to be wholly unremarkable, if not perfectly usable for the task at hand. It was kind of like a strange hybrid of the old Mac OS and Windows 95, with menus and icons all over the place, most of which didn't do anything like what you would expect them to do on either of it's step siblings. There was very little visual consistency and clearly no User Interface guidelines or at least any that were being adhered to it. It was anarchic, wild, chaotic and above all, free. I quickly discovered I could make the UI even more inscrutable by applying a seemingly endless supply of themes, the results of which sometimes rendered the interface almost unusable. After a day or so of wasting time this way, I settled on the default theme with a slightly more muted colour blue and got back to work, mostly using the terminal anyway...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Gnome cerca 2000AD" src="http://chrisdaley.biz/images/gnome-2000.jpg" title="Not my actual Desktop - this one is far too uncluttered" /&gt;&lt;/p&gt;
&lt;p&gt;Time passed and I found myself in some very strange places, with very few computers and almost no internet. It was Windows 2000 all the way baby, and after a while I found myself begrudgingly respecting the stability of the Redmond born beast as it powered on through conditions that few OSs have or will ever have to face. A fierce invalid home from hot climes and in need of a personal computer, I dug out my old Powerbook and installed the version of OS X that had been released whilst I was away from the online world. It ran like a dog. I maxed out the RAM, put in a new HDD and it still screamed "REPLACE ME" everytime I started it up. Unfortunately, the modest amount of money I had made during dot.com 1.0 had been long spent and several years of service in the common good had reduced me to near poverty myself. Spending even more money on buying a new computer was out of the question. I asked one of the neckbeardsI knew and he suggested I try this new Desktop Linux Distro called Ubuntu that everyone was raving about it. With nothing to lose but my sanity I bit the bullet and downloaded the Ubuntu ISO image and after accidentally making a few coasters with my girlfriend's Windows XP machine, I was up and running.&lt;/p&gt;
&lt;p&gt;The first thing that struck me was how pleasant the Desktop was. The Ubuntu humanity theme was, and still is, a very well crafted visual experience. The Gnome Desktop itself was significantly less cluttered and distracting than I remembered. Rather than being a hodgepodge of the worst elements of the Big Two, it had &lt;em&gt;mostly&lt;/em&gt; synthesised the best of both worlds. Things worked as expected, for the most part, and if they didn't, that was because there was a different paradigm at work rather than a bug or unimplemented feature. What's more, I could finally use my Powerbook again without wanting to throw it out the window. The Gimp took some getting used to, but only because I had been a top Photoshop jock and the muscle memory for keyboard shortcuts takes time to retrain. There was some pain, to be sure - the Lombard was a PowerPC after all, and not all the packages were available as binaries. The Package Manager itself left a lot to be desired and on at least one occasion I was painfully reminded that with great power comes great responsibility as I watched the system literally melt away in front of my eyes as I had accidentally uninstalled the Desktop. Still, I was happy and totally hooked on Linux and Open Source, even if the Desktop experience was still pre-XP.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Gnome Ubuntu 2004" src="http://chrisdaley.biz/images/ubuntu.jpg" title="And it was still better than anything on Windows or Mac at the time" /&gt;&lt;/p&gt;
&lt;p&gt;And then the schism happened. The Gnome developers decided it was time for a revolution instead of evolution and Canonical decided to go its own way with Unity. It was like your parents breaking up and your Mum's new boyfriend moving in a week later. Unity was weird and didn't seem to work properly and the same could be said of Gnome 3. I had customised my Desktop with Docky and had set up a bunch of silly effects that never failed to impress (most people just assumed it was a Mac at first, ironically enough) and that was all about to change when Unity became the default. The apocalypse never happened though, I quit my job and bought a Netbook which came with Ubuntu and Unity preinstalled. Suddenly this weird new UI made sense, given that a Netbook's screen "real estate" would only be called generous if it were a New York loft apartment. Within a few short iterations (I love 6 monthly releases) the candy coloured task bar could be hidden and a few more tweaks made it pass from being barely usable to bearable to barely noticed. &lt;/p&gt;
&lt;p&gt;By the time I was back working a normal sized computer, Unity had matured to the point where I didn't even give it a second thought. Thanks to the considerable amount of time and money poured into Ubuntu by Canonical, I had a stable, functional modern desktop that didn't get in the way. I would have stayed completely oblivious to the inanity of the Linux Desktop Wars if not for the occasional foray into various forums in search of solutions or drivers. I didn't care - what I had &lt;em&gt;worked for me&lt;/em&gt;(tm) and boy was it working. Tasks like analysing electoral data by postcode or the cycle of water flows in river catchments and producing high quality visual representations for the web or print. The sort of things that sound like the pitch for very expensive, specialised proprietary software, but available for free on my computer with a single command. This to me was the Linux Desktop that had been long promised - a toolchain of powerful applications accessible through an interface that made them easier to use, not harder. I was more interested in tweaking the precision of my models than any bling. After a few months I realised that my desktop background was still the default. I rarely saw it anyway and I had long ago disciplined myself to resist the siren call of the Desktop folder. Sitting there crunching a massive dataset using purely open source tools, some of which I had written myself, I sure didn't feel like a N00B.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Domo Ubuntu" src="http://chrisdaley.biz/images/domo_ubuntu.png" title="どうも、こんにちは?" /&gt;&lt;/p&gt;
&lt;p&gt;I didn't give it another thought until I went freelance and bought myself a new laptop, the one I'm writing this on today. No matter what I did, I couldn't get the internal Bluetooth adapter to work, either in Windows or Linux. I had read on some forums that the particular chip worked under Mint, so I downloaded the Live CD and tried it out. I wasn't thrilled with the idea of having to switch my OS, and I figured I might be able to isolate what about the Mint configuration made the device work and replicate it on Ubuntu. I was under-whelmed to say the least, and couldn't fathom what all the fuss was about. As far as user interfaces go, my laptop came with Windows 7 installed on it already, why would I opt for an inferior knockoff? In any case, it didn't work - the situation, and configuration, was exactly the same. Finally figuring that the actual hardware itself must be faulty, I popped the case and lo and behold, it was faulty alright, in so far as it wasn't even there. Unlike Windows, Linux wasn't lying, there was no Bluetooth adapter at all. I rechecked all of the paperwork and ... it turns out my particular laptop was a regionally specific model that came without the combination Bluetooth/WiFi that everybody else in the world got. D'oh. Oh well, good to know, especially since that meant I didn't have to install Mint just to be able to use my new Bluetooth headphoes.  &lt;/p&gt;
&lt;p&gt;And so it was for many, many moons. Ubuntu and Unity got progressively more stable and continued to perform almost flawlessly in a mission critical production environment - one where actual lives really were at stake. The interface shone by not shining, by being there when it was needed and not when it wasn't. I was at one with my desktop. Om. Then a serpent entered the garden, it started with a little personal project that would potentially run on Gnome as well as other desktops. In the spirit of best practice, I installed the Ubuntu Gnome Desktop package to see how my app would run under this much maligned interface. I was wary, having read a lot about how the over simplification of the Gnome shell had rendered it unusable for many, that it would be difficult to do common tasks that had once been easy and I would have to install a bunch of third party extensions to be able to get anything done. I was set up for a quick get in, get the screenshot and get out. I nervously logged in, not sure at all what to expect.&lt;/p&gt;
&lt;p&gt;The immediate thing that struck me was the freshness of the interface. Everything moved with a fluidity that was pleasing to the eye. The applications I needed to use were at most two clicks away, and when launched they took over the interface, becoming the sole focus. It took almost no time to figure out this brave new world, especially when things like multiple monitors worked right out of the box. I felt more productive immediately - this was not what I was expecting at all! The naysayers in many of the forums I had visited had clearly written it off at the beta stage, perhaps a little hastily, as it appeared to have blossomed from an ugly duckling into a beautiful, black swan. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Gnome 3 Desktop" src="http://chrisdaley.biz/images/gnome3.png" title="A thing of beauty" /&gt;&lt;/p&gt;
&lt;p&gt;Much of the criticism levelled at Gnome 3 and Unity when they first appeared was that they were too strongly focused on emulating the touch driven interfaces of Android and iOS devices. A great deal was made of the assertion that what works on one platform doesn't translate to another and that the Desktop and the Handheld were fundamentally separate and irreconcilable paradigms. This may have been the case in 2009, but the present is a foreign country from the past, one where they do things differently. If I needed any convincing that this much heralded convergence of the handheld and desktop platform was more than hype, it was when my wife brought home her first Microsoft Surface. There it was, in one sweet, flyweight package, a full powered computer with a super responsive touchscreen. Sure, others had tried before, but M$ have really nailed it with this one. It's no surprise it's the cornerstone of their future hardware strategy and viewed in this light, the Windows 8.0 fiasco looks more ill timed than ill conceived. It's little wonder that Apple have been holding off on merging the Mac OS X and iOS platforms, especially since they don't seem to have a Surface killer lurking in the wings.&lt;/p&gt;
&lt;p&gt;For me, it's a bit of tragedy that this should have happened to the Linux Desktop as well. The user base was and is always going to be small - but that's OK. Despite what it might seem at any Linux conference these days, Mac OS X is not ubiquitous in the wild. Since it saved the Mac as a personal computer platform from obscurity in 2001, it has only increased its market share by some 6-7% and it's extremely unlikely that it will grow any further. Being a "niche" OS hasn't hurt Mac OS X one bit, nor has its deliberate lack of theming features - another complaint often levelled against Gnome. If the Linux Desktop is going to be niche though, it should be in the vanguard, not the fringe. The original, not the cheap knockoff.&lt;/p&gt;
&lt;p&gt;In any case, I'm sold. I now run Gnome exclusively on my Ubuntu laptop and have installed Fedora 23 on a recycled desktop with a new 24" multitouch monitor. I have started to rethink what the Linux User Experience should be and what as I a developer can contribute to that. Above all, Gnome 3 has shown me that using Linux on the desktop can be fun again. &lt;/p&gt;
&lt;p&gt;Welcome Gnome, it's nice to have you back.&lt;/p&gt;</summary><category term="Gnome"></category><category term="Open Source"></category><category term="Linux"></category><category term="Desktop"></category><category term="Ubuntu"></category></entry></feed>