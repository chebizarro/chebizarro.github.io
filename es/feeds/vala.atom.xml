<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Entrar al Panóptico</title><link href="http://chrisdaley.biz/es/" rel="alternate"></link><link href="http://chrisdaley.biz/feeds/vala.atom.xml" rel="self"></link><id>http://chrisdaley.biz/es/</id><updated>2016-01-27T16:50:00-08:00</updated><entry><title>Towards a Test Driven Development Framework in Vala Part 4. Who Tests the Tester?</title><link href="http://chrisdaley.biz/es/test-driven-development-in-vala-pt-4-en.html" rel="alternate"></link><updated>2016-01-27T16:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-27:es/test-driven-development-in-vala-pt-4-en.html</id><summary type="html">&lt;p&gt;After a short break to work on one of my other projects (&lt;a href="http://www.last.fm/music/Calisse"&gt;a Rock 'n Roll band&lt;/a&gt;) and finish setting up &lt;a href="http://jenkins.valadate.org:8080"&gt;Jenkins&lt;/a&gt;, I'm back at work on the project now officially known as &lt;a href="https://github.com/chebizarro/valadate"&gt;Valadate&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As I've mentioned before, there were some initial attempts at developing a TDD framework for Vala, the most extensive of them being &lt;a href="https://github.com/yorba/valadate"&gt;Valadate&lt;/a&gt;. After some consideration, and a review of the existing codebase, I decided that the most practical approach would be to assume maintainership of it and refactor/rewrite as necessary to meet the new requirements that have been gathered.&lt;/p&gt;
&lt;p&gt;Presently, the existing Valadate package provides a number of utility classes for such things as asynchronous tests and temporary directories as well as a command line Test Runner. The procedure for writing tests is to create a concrete implementation of the Valadate Fixture interface with each unit test being a method whose name starts with &lt;code&gt;test_&lt;/code&gt;. The test is then compiled into a binary (shared library) which is run by the Test Runner. Test discovery is done by loading the .vapi and .gir files generated by Vala when the binary is compiled. The build system is &lt;a href="https://en.wikipedia.org/wiki/Waf"&gt;Waf&lt;/a&gt;, but for the purposes of reviewing the code, I ported it to autotools, a build system I am more comfortable with, although it can still be built with Waf.&lt;/p&gt;
&lt;p&gt;The code compiles, but it has suffered from some bitrot, with quite a number of deprecation warnings, especially the asynchronous tests. The actual framework is quite lean and uses the GLib Test and TestSuite classes to group and run the tests it finds in the binary. In total there probably isn't more than 1000 SLOC in the whole project. While I see some interesting ideas in the current code, I have decided that the best approach is to start again from scratch and incorporate whatever is useful and send the remainder to binary heaven || hell.&lt;/p&gt;
&lt;p&gt;So now that I have the repository for Valadate forked and updated to build with autotools, I will use this as the &lt;code&gt;master&lt;/code&gt; from which we will derive the various development branches, using the widely practiced &lt;a href="https://guides.github.com/introduction/flow/"&gt;"GitHub Flow"&lt;/a&gt;, a repository management process which embodies the principles of Continuos Integration. In a nutshell, it involves six discrete steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a branch for developing a new feature&lt;/li&gt;
&lt;li&gt;Add commits to the branch&lt;/li&gt;
&lt;li&gt;Open pull requests&lt;/li&gt;
&lt;li&gt;Discuss and review the code&lt;/li&gt;
&lt;li&gt;Deploy&lt;/li&gt;
&lt;li&gt;Merge&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The underlying principle (or "one rule" as GitHub calls it) is that the &lt;code&gt;master&lt;/code&gt; branch is always deployable - which in the case of a tool like Valadate means it can be pulled, compiled and run at any time. So while the existing &lt;code&gt;master&lt;/code&gt; branch of Valadate is not exactly production ready, it is in the state where the Yorba Foundation stopped maintaining it. This at least gives us a baseline from which to start and some continuity with the original project, if only giving credit to the original developers for their hard work.&lt;/p&gt;
&lt;p&gt;We're ready to branch our new version, so what do we call it? The most commonly used system is &lt;a href="http://semver.org/spec/v2.0.0.html"&gt;Semantic Versioning&lt;/a&gt; which follows the MAJOR.MINOR.PATCH convention:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MAJOR version when you make incompatible API changes,&lt;/li&gt;
&lt;li&gt;MINOR version when you add functionality in a backwards-compatible manner, and&lt;/li&gt;
&lt;li&gt;PATCH version when you make backwards-compatible bug fixes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The last release of Valadate was 0.1.1 and it's not entirely clear if they were strictly following the Semantic Versioning scheme. There are separate API and SO version numbers which may not be applicable in our first release. So for simplicity, I will use the original version number as the starting point. As we are going to make some fairly substantial changes that would break the hell out of the 0 API, we should probably increment that to 1. Since we are starting from scratch, the MINOR version will revert to 0 as well. So the branch name that we will begin working on our new implementation under will be 1.0.0.&lt;/p&gt;
&lt;p&gt;Sweet. Let's dial up those digits:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ git checkout -b version-1.0.0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The local repository is now a new branch called &lt;code&gt;version-1.0.0&lt;/code&gt;, which will allow us to start really overhauling the code without affecting the "deployable" &lt;code&gt;master&lt;/code&gt; branch. Since we're going to break more things than a stoner in a bong shop, we may as well reorganise the file layout to something more conventional and dispose with the Waf build system altogether.&lt;/p&gt;
&lt;p&gt;Our new repository directory structure looks like this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;valadate&lt;ul&gt;
&lt;li&gt;libvaladate&lt;/li&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;li&gt;tests&lt;ul&gt;
&lt;li&gt;libvaladate&lt;/li&gt;
&lt;li&gt;src&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This structure is a fairly commonly used pattern in developing medium to large size projects, you essentially replicate the source tree within the tests folder. This makes it easier to locate individual tests and means your integration tests will follow the same basic pattern as the main source tree does at compile time. With smaller projects, you could just get away with a simple &lt;code&gt;tests&lt;/code&gt; directory - with the relatively small SLOC that Valadate has now it could probably all reside within a single source file! Given that we expect the project to grow significantly though, especially when we start adding complex features like BDD tests and a GUI as well as several layers of tests of tests, we should probably start with a more scalable structure.&lt;/p&gt;
&lt;p&gt;OK, now we're finally ready to start writing tests. Given that this is a Testing Framework, we're facing a potential chicken and egg situation - what framework do we use to test our framework? In this case, the solution is pretty straightforward, we have the GLib Test suite at our disposal which we can use to write the base tests that will guide the design of the framework. Once these tests all pass, we can move on to using Valadate to test itself when adding more complex testing features like Gherkin/Cucumber. Finally, we can use those features for even more complex testing such as user acceptance and integration tests for the project as a whole. The process is iterative and cascading, meaning that as features at one level are sufficiently tested they will become available for the next successive layer of tests. You could think of it like an Onion, if you like, or a series of waterfalls but my mental image at the moment is more like this:&lt;/p&gt;
&lt;p&gt;
&lt;iframe allowfullscreen="true" frameborder="0" height="315" src="//www.youtube.com/embed/eMqGdRqj1_0" width="560"&gt;&lt;/iframe&gt;
&lt;/p&gt;
&lt;p&gt;But that's just me. Use whatever metaphor you like, it's your head after all.&lt;/p&gt;
&lt;p&gt;So we begin using the basic or 'naked' (as I like to call it) &lt;a href="https://developer.gnome.org/glib/stable/glib-Testing.html"&gt;GLib Testing Framework&lt;/a&gt;. Now the GLib Testing Framework is actually pretty powerful and was originally designed according to the xUnit interface. It's fairly straightforward to use, as this example from the &lt;a href="https://wiki.gnome.org/Projects/Vala/TestSample"&gt;Gnome Vala Wiki&lt;/a&gt; shows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;add_foo_tests&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/vala/test&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;assert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;ref&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;add_foo_tests&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;It also has the gtester and gtester-report utilities which are well integrated with existing toolchains and are able to output test results in a variety of formats.&lt;/p&gt;
&lt;p&gt;The main drawbacks of the GLib Testing Framework, and hence the need for Valadate at all, are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is not particularly Object Oriented - the base classes are all &lt;code&gt;[Compact]&lt;/code&gt; classes and do not inherit from a common Test base class. This makes extending them in Vala difficult.&lt;/li&gt;
&lt;li&gt;The test report functions need a lot of configuration to produce usable output, including several 'drivers' or shell scripts for postprocessing.&lt;/li&gt;
&lt;li&gt;It is not particularly well documented&lt;/li&gt;
&lt;li&gt;It doesn't scale very well to large projects or for Behavior Driven Design.&lt;/li&gt;
&lt;li&gt;It's verbose and difficult to read.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most of these limitations are solveable in one form or another, so it should serve as a sufficient base to get started. If we follow the principles of Test Driven Design it should become obvious when we need to build something more powerful or flexible.&lt;/p&gt;
&lt;p&gt;Which tests and features do we write first? Well, that's determined by the requirements we've gathered and how we've prioritised them. One of the many great things of having a wife who is a CTO for a foundation developing open source land tenure software is that I get to vicariously experience how she manages her team's workflow and the tools they use to do that. One of the recent tools that they have started using for project management is &lt;a href="https://waffle.io/"&gt;Waffle&lt;/a&gt;, which integrates seemlessly with GitHub Issues and Pull Requests. Waffle is the next step beyond the &lt;a href="http://bit.ly/1ZSrRA6"&gt;Trello board&lt;/a&gt; that I was using to initially gather the requirements for Valadate. Waffle allows anyone to add a feature request or file a bug to the Backlog either through the &lt;a href="https://waffle.io/chebizarro/valadate"&gt;Waffle board&lt;/a&gt; for the project or by simply creating a &lt;a href="https://github.com/chebizarro/valadate/issues/new"&gt;new issue&lt;/a&gt; on the GitHub page. The latter is the most straightforward as you don't need to log into Waffle at all.&lt;/p&gt;
&lt;p&gt;One of my wife's philosophies of Open Source is that it's not enough to just release your source code. A true Open Source project is also developed in the open, meaning that the history behind why certain design decisions were made, and by who, is recorded and all issues and pull requests are reviewed and where they meet the project's (i.e. enduser's) requirements, are fixed or merged, regardless of the source. Public repositories are, at the very least mirrors if not the working versions of the current master and branches, not just static snapshots of a final release.&lt;/p&gt;
&lt;p&gt;Taking an Open from the Start approach is also something that is essential in building a strong, diverse community of users around your product. Sarah Sharp, a long time Linux Kernel contributer, has written extensively about this on her &lt;a href="http://sarah.thesharps.us/2015/10/06/what-makes-a-good-community/"&gt;blog&lt;/a&gt;. One of the things that I'm going to take the opportunity to lock down now is a Code of Conduct for contributors. I'm not going to go into the pros and cons of having a Code of Conduct - as I don't see any cons in the first place! So, as Sarah says on her blog -&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We don’t write legal agreements without expert help. We don’t write our own open source licenses. We don’t roll our own cryptography without expert advice. We shouldn’t roll our own Code of Conduct.&lt;a href="http://sarah.thesharps.us/2016/01/25/code-of-conducts-warning-signs/"&gt;1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With that in mind, I've signed the project on to the &lt;a href="http://todogroup.org/opencodeofconduct/#Valadate/chebizarro@gmail.com"&gt;Open Code of Conduct&lt;/a&gt;, which is used by GitHub and is inspired by the codes of conduct and diversity statements of projects like Django, Python and Ubuntu. It's worth a read, even if it's your bread and butter, but here's my summary - "don't be an asshat" - and you can tweet me on that.&lt;/p&gt;
&lt;p&gt;So that's all for this post, join me again soon for Part 5 where I will outline the product roadmap for the first release and delve into when we know we've tested enough with coverage reports. Thanks for reading and please feel free to join the conversation if you have something to say!&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Hacia un framework de desarrollo guiado por pruebas para Vala - tercera parte - DevOps - Integración Continua con Jenkins</title><link href="http://chrisdaley.biz/es/test-driven-development-in-vala-pt-3.html" rel="alternate"></link><updated>2016-01-19T10:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-19:es/test-driven-development-in-vala-pt-3.html</id><summary type="html">&lt;p&gt;&lt;a href="https://es.wikipedia.org/wiki/Integraci%C3%B3n_continua"&gt;Integración Continua&lt;/a&gt; o IC está ampliamente usado en TDD para mantener la base de código de un proyecto bien ordenada, reduciendo los errores y asegurando que hay siempre ejecutables disponibles para desplegar. Proporciona medios para automatizar el proceso de compilar y probar, así que los desarrolladores se pueden enfocar en escribir pruebas y el código que las pasara. Mediante la instalación de un sistema que compila y prueba el software en las plataformás que las soporta, los problemás de despliegue pueden ser identificados temprano y la distribución de los nuevos lanzamientos automatizados.  &lt;/p&gt;
&lt;p&gt;Dado que uno de los objetivos de Valadate es integrarse en las cadenas de herramientas ya existente, y con ganas de aprovechar los beneficios numerosos para el proyecto si mismo, tome un pequeño break de &lt;a href="https://es.wikipedia.org/wiki/DevOps"&gt;DevOps&lt;/a&gt; para instalar un sistema basado en &lt;a href="https://es.wikipedia.org/wiki/Jenkins"&gt;Jenkins&lt;/a&gt; en mi red local. Jenkins es un servidor de Integración Continua de codigo abierto que está ampliamente usado. Escrito en Java, se puede ejecutar en cualquier en cualquier sistema, dado que tenga suficiente potencia. Llevándose al extremo, decidí instalarlo en un Raspberry Pi 2 que tenia por ahí. Por que Jenkins y por que en un Raspberry Pi?&lt;/p&gt;
&lt;p&gt;En primero, el Jenkins es una plataforma robusta y mantenida que está ampliamente usado. Hay una plétora de complementos que integrarse bien con Git, Docker, TAP y muchos otros herramientas y protocoles de IC. Se basa en el modelo de amo-esclavo, donde el servidor amo dirige las operaciones de compilar en cualquier numero de esclavos. Un esclavo puede ser cualquier otra computadora en la red que puede comunicarse con Jenkins, o directamente a través de SSH o con un complemento. Es fácil de configurar y sencillamente funciona. Me parecía una buena elección por empezar.&lt;/p&gt;
&lt;p&gt;&lt;img alt="La interfaz wed de Jenkins" src="http://chrisdaley.biz/es/../images/jenkins.png" /&gt;&lt;/p&gt;
&lt;p&gt;En segundo, la Raspberry Pi. Uno de las consideraciones en armar el sistema de IC fue que el servidor amo debe ser accesible por la internet y disponible 24x7. Dado que cuando no hay tareas en marcha el servidor está más o menos desocupado, utilizando una computadora de plena potencia seria una perdida de energía y dióxido de carbono. Me di cuenta que una de las Raspberry Pi que no estaba ocupada podría hacer el trabajo, así que después de una búsqueda rápida de Google para confirmar que sea posible, seguí con la instalación. La guía más comprensiva que encontré sugirió huevadas como descargar paquetes de código fuente pero dado que esa fue para una versión previa de Raspbian, intentaba con &lt;em&gt;sudo apt-get install jenkins&lt;/em&gt; y salio nomás.&lt;/p&gt;
&lt;p&gt;Con el servidor de Jenkins ya en marcha, agregue el &lt;a href="http://github.com/chebizarro/gherkin-vala"&gt;port de Gherkin&lt;/a&gt; que recién lancé como una prueba y arme una maquina con Fedora 23 como esclavo y dentro de 5 minutos lo había hecho checkout, compilado y ejecutado las pruebas y...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Build Status" src="http://chrisdaley.biz/es/../images/passing.png" /&gt;&lt;/p&gt;
&lt;p&gt;\O/ \O/ \O/&lt;/p&gt;
&lt;p&gt;A pesar de tener poco potencia, la Raspberry Pi parece adecuada para la tarea, como no compilar nada. Algunas de las paginas de configuración tarden un ratito en cargar pero para el uso ordinario parece rápida. No solo eso, sino puedes hacer &lt;a href="https://www.perforce.com/blog/150910/continuous-delivery-fun-jenkins-raspberry-pi"&gt;cosas chulas&lt;/a&gt; también. &lt;/p&gt;
&lt;p&gt;Animado por el éxito inicial, arme un esclavo de Docker. Para esta configuración, reanime un antiguo servidor que había sido mothballed, con la idea que como un esclavo de compilar, no necesitara estar en linea todo el tiempo y con Wake On Lan (WOL) puedo mandar que Jenkins despierte el servidor cuando necesite hacer una tarea y adormecerlo cuando se termina. Eso todavía se queda por hacer pero me parece sencillo. &lt;/p&gt;
&lt;p&gt;Con esta configuración, el esclavo es un anfitrión de Docker y se arranca y ejecutar un contenedor armado de un Dockerfile en la raíz del repositorio. Es este contenedor que ejecutar la compilación, no el anfitrión, asimismo es posible probar tu software en casi cualquier plataforma que se puede dockerize. Que guay no? Entonces, arme un contenedor de Ubuntu y...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Build Status" src="http://chrisdaley.biz/es/../images/failing.png" /&gt;&lt;/p&gt;
&lt;p&gt;Como que? Mire el log y...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;./.libs/libgherkin3.so: undefined reference to `g_value_init_from_instance&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Maldito sea! En la prisa de portear Gherkin, lo hice en mi nuevo sistema de Fedora 23 y no lo había probado nada en Ubuntu. Comprobé los documentos y por cierto, GLib.Value.init_from_instance() está disponible a partir de la version 2.42 de GLib y el Ubuntu 15.04 solamente lleva la versión 2.40. D'oh! Así que tengo que refactorizarlo o declarar GLib 2.42 como requisito.&lt;/p&gt;
&lt;p&gt;Este caso en particular es un muy buen ejemplo de los beneficios de Integración Continua. Si tuviera el servidor de Jenkins armado antes de portear el código, me habría dado cuenta de la incompatibilidad casi de inmediato y lo habría arreglado en aquel momento, más bien que refactorizarlo más tarde. &lt;/p&gt;
&lt;p&gt;Aunque seria bonito ignorar la existencia de los otros sistemás operativos, la verdad triste es que no todo el mundo usar el Linux como su escritorio principal, incluso ya mucha gente que tal vez querría usar mi software. Conciente de esa realidad brutal, decidí armar esclavos de Windows y Mac OSX para probar la compatibilidad multiplataforma de mis proyectos. &lt;/p&gt;
&lt;p&gt;Para el esclavo de Windows, instale una nueva VM de Windows 7 en VirtualBox, ejecutando en el mismo servidor que el anfitriona de Docker. Para la cadena de herramienta, instale MingGW64 y MSYS2 y todas las bibliotecas necesarias y voila! Pues, no exactamente voila, el linker de MinGW es tan despacio que me costo bastante tiempo depurarlo pero ya funciona bien. El proceso no es totalmente automático - tengo que arrancar y apagarlo a mano. Hay un complemento de VirtualBox para hacer todo eso pero actualmente no soporta la versión 5. Tambien aprendí por las malas que hay que deshabilitar las actualizaciones automáticas para Windows, si no se trabara en la pantalla de arranca fallada. Además para darle prisa un poquito, tengo pensado compilar los binarios en un contenedor de Docker a ejecutar las pruebas el la VM de Window para asegurar que funcionan correctamente.&lt;/p&gt;
&lt;p&gt;Ahora bien, si has asistido a cualquier conferencia mayor de Linux en los últimos anos, podrías concluir que estuvieras en WWDC con todo los equipos de Apple que se veía en todas partes. Vaya, aun mi esposa, una guru de software libre, usaba un MacBook Air por mucho tiempo hasta que compró un Microsoft Surface. Y es la verdad, es unos de los equipos más chulo y caro para ejecutar una Maquina Virtual de Linux. No me entiendes mal - tengo uno en el escritorio, lo uso para email, IRC y la sesión ocasional de Photoshop (por lo menos hasta que el Gimp soporte mejor las tablas). Desafortunadamente, está un poco descuidado así que necesitara un poquito de limpieza antes de ser puesto a disposición, ojala antes del comienzo de la semana que viene.&lt;/p&gt;
&lt;p&gt;Lo largo del camino, descubrí que nuestro Modem de Cable de mierda, proporcionado por Comcast no soporta las resoluciones DNS de horquilla cuando redirigí los puertos del servidor Jenkins. Intentaba resolver eso mediante instalar dnsmásq en la Raspberry Pie pero aun así necesitaba editar a mano los archivos de resolv.conf en cada maquina. Al final, puse el Modem de Comcast en modo puente y arme un viejo pero confiable WRT-54GL con DD-WRT como el nuevo Gateway/Router. Aun tiene problemás con el DHCP de IPv6 pero por lo menos funciona bien.&lt;/p&gt;
&lt;p&gt;Entonces ya está, un sistema de Integración Continua multiplataforma compilando proyectos basados en Vala. Está en vivo en la internet ahora, así que se puede ver &lt;a href="http://jenkins.valadate.org:8080"&gt;aqui&lt;/a&gt; (se requiere login de Github).&lt;/p&gt;
&lt;p&gt;Venga, ya estamos listos para empezar a construir Valadate! Sintonice de nuevo prontito para la cuarta parte - Quien pone a prueba el probador? &lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Código Abierto"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category><category term="Jenkins"></category><category term="Integración Continua"></category><category term="DevOps"></category></entry><entry><title>Hacia un framework de desarrollo guiado por pruebas para Vala - segunda parte - Requisitos y Arquitectura de Sistema</title><link href="http://chrisdaley.biz/es/test-driven-development-in-vala-pt-2.html" rel="alternate"></link><updated>2016-01-13T10:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-13:es/test-driven-development-in-vala-pt-2.html</id><summary type="html">&lt;p&gt;Ya hace menos de una semana desde que lancé un &lt;a href="http://chrisdaley.biz/es/../test-driven-development-in-vala-pt-1.html"&gt;post&lt;/a&gt; pidiendo input a mi propuesta de armar un framework de desarrollo guiado por pruebas para Vala y las reacciones han empezado de llegar. Se puede ver un resumen &lt;a href="https://gist.github.com/chebizarro/6c949fafe1e9a2c59b26"&gt;aquí&lt;/a&gt; lo que ha sido destilado en una &lt;a href="http://bit.ly/1ZSrRA6"&gt;placa de Trello&lt;/a&gt; lo que se convertirá en el Product Backlog y el Product Roadmap. La lista me parece más o menos completa hasta ya así que pienso que está al punto de cerrarse y elaborar un Release Plan. Por fin! Puedo empezar a escribir código. Uf!&lt;/p&gt;
&lt;p&gt;Los requisitos recopilados hasta ahora son prácticamente iguales con los otros frameworks de pruebas pero este es una buena hora para revisar nuestra Visión de Producto para ver si nuestro rumbo es correcto. He destacado las partes de la declaración que corresponden con características para que podamos compararlas.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Para los desarrolladores de Vala que necesitan probar su código, &amp;lt; insertar el chulo nombre de herramienta &amp;gt; es un framework de pruebas de gran potencia que &lt;strong&gt;proporciona funciones de pruebas de las características de comportamiento, funcionales y  unitarias&lt;/strong&gt; para ayudarles a escribir gran software de código abierto. La diferencia con los otros frameworks de prueba y &amp;lt; insertar el chulo nombre de herramienta &amp;gt; es que está &lt;strong&gt;diseñado especialmente para Vala&lt;/strong&gt;, y &lt;strong&gt;integra perfectamente en las cadenas de herramientas ya existentes&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Echamos un vistazo a los requisitos que hemos recopilado hasta ya y averiguamos si esas características se caben con esa visión. &lt;/p&gt;
&lt;p&gt;&lt;img alt="Product Backlog" src="http://chrisdaley.biz/es/../images/requirements.png" /&gt;&lt;/p&gt;
&lt;h4&gt;proporciona funciones de pruebas de las características de comportamiento, funcionales y  unitarias&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Descubrimiento de pruebas&lt;/li&gt;
&lt;li&gt;Pruebas asincrónicas&lt;/li&gt;
&lt;li&gt;Test Runner&lt;/li&gt;
&lt;li&gt;Apoya Gherkin&lt;/li&gt;
&lt;li&gt;Afirmas&lt;/li&gt;
&lt;li&gt;Probar comportamiento protegido&lt;/li&gt;
&lt;li&gt;Pruebas abstractas&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;diseñado especialmente para Vala&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Apoya Genie&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;integra perfectamente en las cadenas de herramientas ya existentes&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Emisión de TAP&lt;/li&gt;
&lt;li&gt;Compatible con gstester&lt;/li&gt;
&lt;li&gt;ILC y IGU autónoma&lt;/li&gt;
&lt;li&gt;binarios PIE&lt;/li&gt;
&lt;li&gt;Integrar con herramientas de integración continua como Jenkins&lt;/li&gt;
&lt;li&gt;Las pruebas pueden ser compilados y ejecutado si tener el framework instalado&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hasta aquí todo bien! Por supuesto, este es un proyecto Ágil, así que está lista no es comprensiva ni final y se puede suponer que otras características se añadieren mientras que otras sean modificadas o quitadas completamente. La cosa más importante es que las características se alinea con nuestra visión. El resultado de este proceso de priorización sera el Product Roadmap y el Product Backlog, los cuales guían los sprints y los esfuerzos diarios de desarrollo y informen el programa de lanzamiento. Ante todo eso, necesitamos dirección en como vamos a dividir esas características en áreas funcionales lo que determina como vamos a estructurar nuestra base de código y donde podemos empezar escribiendo pruebas. Para esto, se necesita una arquitectura de sistema. &lt;/p&gt;
&lt;h3&gt;La arquitectura de sistema y TDD&lt;/h3&gt;
&lt;p&gt;Uno de los conceptos erróneos que tienen los novatos a TDD es que no escribes nada hasta que hay una prueba. Eso confunde a mucha gente y las deja sin saber donde empezar, como una aplicación sencilla de la linea de comando requiere una cierta cantidad de código repetitivo antes de procesar el input del usuario. Desde este punto, muchos novatos escribirían montones de pruebas redundantes o inventan ruedas ya bien probadas de nuevo o renuncian TDD por completo. Hay pocas veces cuando tu código sera ejecutando sin dependencias (si solo libc) pues siempre estas escribiendo código dentro de un framework existente, si no aproximadamente. La mayoría de estas interacciones con otros frameworks debería ser encapsulado en las pruebas de integración, las que son desarrollada en paralelo con las pruebas unitarias. Las pruebas que informen nuestro diseño de sistema son las que prueban sus características únicas. Nuestra arquitectura de sistema define esas interacciones y limites y nos da un esqueleto básico para empezar a escribir nuestra base de código. Una vez que esta hecha, podemos empezar a escribir las pruebas concretas que nos van a guiar el diseño.&lt;/p&gt;
&lt;p&gt;Con un proyecto como este tenemos la ventaja de unas muestras de la técnica anterior, la arquitectura de &lt;a href="https://es.wikipedia.org/wiki/XUnit"&gt;xUnit&lt;/a&gt; siendo la mayor entre ellas. xUnit es un framework flojo que incluye JUnit y Nunit y estipula que cualquier implementación tenga una arquitectura común, como se puede ver en el diagrama abajo.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Diagrama de clases de xUnit" src="http://chrisdaley.biz/es/../images/architecture.png" /&gt;&lt;/p&gt;
&lt;p&gt;De este diagrama podemos aun ver como vamos a estructurar el código. Como mínimo, vamos a crear archivos y pruebas distintos para Test, TestRunner, TestSuite, TestCase, TestFixture and TestResult. Si, pruebas para pruebas. Hubiera dicho que esto resultaría interesante... Este nos van a dar el mínimo que necesitamos para armar una cadena de herramientas y crear un repositorio de código. Enhorabuena, estamos al punto de empezar! Salvo que todavía no tiene nombre... &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;¿Qué tiene un nombre? Lo que llamamos rosa olería tan fragante con cualquier otro nombre.&lt;/p&gt;
&lt;p&gt;William Shakespeare&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Gracias Guili. Todavía no estoy totalmente entusiasmado con el nombre de Valadate, aunque refleja la Vision de Producto de ser diseñado especialmente para Vala y que no está solamente para las pruebas unitarias. Llamarle VUnit reflejara su procedencia de xUnit pero no es como si hubiera una API rígida para conformarse. Técnicamente en este etapa del desarrollo, no importa nada sino que me gustaría evitar los cambios innecesarios más tarde. Todavía se queda más trabajo antes de empezar escribir código, así que voy a dejarlo filtrarse por una dia o dos antes de tomar una decisión firma. Pues bien, ya es la hora de decir algo si te sientes apasionado de una u otra forma.&lt;/p&gt;
&lt;p&gt;Pero por lo menos tiene un logotipo! Dime lo que piensas...&lt;/p&gt;
&lt;p&gt;&lt;img alt="Un sistema solar estilizado visto por un ángulo oblicuo" src="http://chrisdaley.biz/es/../images/valadate_logo.png" /&gt;&lt;/p&gt;
&lt;p&gt;La base fue diseñado por &lt;a href="https://thenounproject.com/misirlou/"&gt;misirlou&lt;/a&gt; y agregue los colores chulos. La idea es que simboliza el asteroide epónimo que da el Vala su nombre.&lt;/p&gt;
&lt;p&gt;Pues ya está, vuelva a sintonizar prontito cuando voy a hablar de los Roadmap y Backlog además como instale Jenkina CI en un Raspberry Pi.&lt;/p&gt;</summary><category term="Vala"></category><category term="Código Abierto"></category><category term="Programación"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Adiós Thin White Duke - un tributo a David Bowie en Vala</title><link href="http://chrisdaley.biz/es/farewell-duke.html" rel="alternate"></link><updated>2016-01-11T17:00:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-11:es/farewell-duke.html</id><summary type="html">&lt;p&gt;Estaba mirando el asteroide 131 Vala, lo que dio su nombre al lenguaje de programación, en el &lt;a href="http://ssd.jpl.nasa.gov/sbdb.cgi?sstr=131;cad=1;old=0;orb=1;cov=0;log=0#orb"&gt;JPL Small Object Database&lt;/a&gt;  cuando me llego la noticia triste del fallecimiento de el David Bowie. Como muchos de mi edad, crecía sin saber nada de un mundo sin viaje espacial, el amenazo de guerra nuclear o el Thin White Duke. No había otro artista capaz de captar aquel sentido de asombro y miedo de una especie caminando en la cuerda floja hacia su destino. Podríamos tropezar y caer en el olvido o alcanzaremos las estrellas? Eran todos los héroes como el Major Tom? Frágil y imperfecto, sin embargo con coraje cautivador.&lt;/p&gt;
&lt;p&gt;Estuve pensando en esas cosas cuando estaba mirando el website de JPL y me di cuenta que el venerable Orbit Viewer applet ya no estaba funcionando. Yo querría ver unos cuerpos celestes moverse esa mañana con una banda sonora de David Bowie así que descargue el código fuente del applet y lo porte a Vala. Para la musica, agregue un pequeño reproductor de gstreamer que carga y toca un archivo Midi de &lt;a href="http://www.midiworld.com/files/1018/"&gt;midiworld.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;
&lt;iframe allowfullscreen="true" frameborder="0" height="315" src="//www.youtube.com/embed/4lQcdikEdJU" width="560"&gt;&lt;/iframe&gt;
&lt;/p&gt;
&lt;p&gt;Portear código de Java a Vala es relativamente fácil, especialmente cuando el código es más viejo y no tiene muchos de los trucos raros que se han introducido en el lenguaje tras tantos años. La parte más rápida de portear fue la biblioteca de funciones para calcular las orbitas, ya que esto es mas o menos pura matemática. La parte mas complicada fue la interfaz, la que creé de nuevo en Glade y las rutinas de dibujar para animar todo. Estaba trabajando en un port del motor de física Box2D, así que he resuelto muchos de esos problemas antes. El resultado final se ve arriba.&lt;/p&gt;
&lt;p&gt;Todavía le falta un poquito de trabajo antes de ser completo - solamente el buton de reproducción funcionar y aun no hay forma de ajustar el puerto de vista - pero esos son fáciles de implementar. Si le interesa a alguien, pondré todo en un repositorio de Github - tanto las rutinas de la física y la animación son bien interesante para principiantes aún con la falta de comentarios. &lt;/p&gt;
&lt;p&gt;Pues bien, gracias por mirar y gracias a ti Starman, por todos los años dorados...&lt;/p&gt;</summary><category term="Vala"></category><category term="Código Abierto"></category><category term="JPL"></category><category term="David Bowie"></category></entry><entry><title>Hacia un framework de desarrollo guiado por pruebas para Vala - primera parte</title><link href="http://chrisdaley.biz/es/test-driven-development-in-vala-pt-1.html" rel="alternate"></link><updated>2016-01-08T10:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-08:es/test-driven-development-in-vala-pt-1.html</id><summary type="html">&lt;p&gt;Encontre &lt;a href="https://wiki.gnome.org/Projects/Vala"&gt;Vala&lt;/a&gt; por la primera vez cuando estaba averiguando la posibilidad de portear un viejo programa de código abierto desde GTK + 2 a GTK + 3. Yo no estaba muy seguro de qué hacer con Vala en aquel momento - era un lenguaje de programación orientado a objetos basado en el sistema de objetos de GObject y utilizaba C como el lenguaje intermediario con el compilador de gcc. Después de leer un montón de muestras, me llamó la atención la elegancia y parsimonia de la sintaxis y cómo fue comprensible de inmediato por mi familiaridad con Java y C #. Jugué con algunas aplicaciones de ejemplo y me sorprendió tal divertido fue utilizarlo también. Era GObject sin las interminables resmas de código repetitivo. Propiedades ya tenía sentido y el uso de señales resultaba mojo de pavo. Fue soportado por los ambientes de desarrollo integrado (IDE) tal como cualquier otro lenguaje, especialmente por Geany, mi herramienta preferida. Me enganché.&lt;/p&gt;
&lt;p&gt;Había un problema solamente. Soy un gran fan de &lt;a href="https://es.wikipedia.org/wiki/Desarrollo_guiado_por_pruebas"&gt;desarrollo guiado por pruebas&lt;/a&gt; o TDD (por sus siglas en ingles)  y después de muchas horas de intensa Google-Fu, encontré muy poco sobre el tema en respecto al Vala. Lo que &lt;a href="https://esite.ch/2012/06/writing-tests-for-vala/"&gt;hubo&lt;/a&gt; fue básicamente utilizar las funciones de prueba de la biblioteca GLib y una pequeña clase adaptador para agrupar los casos de prueba particulares en un conjunto de pruebas. El resultado final se llevó a cabo a través de &lt;code&gt;gtester&lt;/code&gt; por la línea de comandos, en general como parte de una cadena de herramientas como Autotools. Esto bastaba para aplicaciones sencillas con interacciones limitadas con el usario, pero en realidad no escala para el &lt;a href="https://es.wikipedia.org/wiki/Desarrollo_guiado_por_comportamiento"&gt;desarrollo guiado por comportamiento&lt;/a&gt; (BDD en ingles). Alguien había desarrollado un framework llamado &lt;a href="https://github.com/yorba/valadate"&gt;Valadate&lt;/a&gt; pero esto fue abandonada por sus mantenedores ya hace unos años. Esto fue un verdadero bloqueo para mí. La filosofía mía es que de vez en cuando se puede escribir gran software en los momentos furiosos de creatividad pero se precisan pruebas aburridas para producir software de calidad consistentemente.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Su falta de preubas de unidad me resulta molesta" src="http://chrisdaley.biz/es/../images/unit-tests-dv.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;La trampa con el software libre es que solamente no cuesta nada en el cajero. Una vez que llegues a casa, tienes que pagar el costo de mantenimiento en tiempo si quieres seguir utilizándolo. Ese tiempo podría ser gastado en hacer contribuciones menores, como la presentación de informes de errores o dar ayudar a los nuevos usuarios en los foros o la traducción de aplicaciones hasta agregando y desarrollando funciones neuvas. Yo veo mucha potencia en Vala pero siento que esta falta le debilita mucho. Los desarrolladores del lenguaje han dado un gran regalo al mundo y su tiempo sería mejor ocupado en mantenerlo. La solución que ya existe es &lt;em&gt;casi&lt;/em&gt; suficiente, pero genera una gran cantidad de código para mantener y no hay soporte para BDD. "Alguien debería hacer algo" es una frase que me molesta mucho al escuchar, porque creo que ese alguien debería ser la persona que la dijo. Bueno, alguien debería hacer algo...&lt;/p&gt;
&lt;p&gt;Así que esta entrada del blog es un esfuerzo para tomar la iniciativa. Aunque en este momento tengo un poquito de tiempo libre, eso no var a ser el caso por siempre. Asimismo, no quiero empezar un proyecto vaporware o abandonadoware que sería agregado a la lista de buenas ideas que alguien tenía. Me gustaría construir algo que sea sostenible, que evolucione con sus usuarios y que podría ser traspasado a otros mantenedores si no tendría tiempo suficiente para dedicarme an ello. Me imagino que esto ha sido el manifiesto de miles de proyectos de código abierto ya fallados, pero es mejor que nada - así que hay va ...&lt;/p&gt;
&lt;h3&gt;Tomar la iniciativa&lt;/h3&gt;
&lt;p&gt;Dado que el objetivo del proyecto es capacitar Vala con TDD y BDD, me gustaría utilizar las técnicas de Agile para planificar y desarrollarlo. En este caso, los primeros pasos serían la creación de una visión de producto y la recopilación de los requisitos. Voy a tomar el primer paso (citado porque VISIÓN DE PRODUCTO).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Para los desarrolladores de Vala que necesitan probar su código, &amp;lt; insertar el chulo nombre de herramienta &amp;gt; es un framework de pruebas de gran potencia que proporciona funciones de pruebas de las características de comportamiento, funcionales y  unitarias para ayudarles a escribir gran software de código abierto. La diferencia con los otros frameworks de prueba y &amp;lt; insertar el chulo nombre de herramienta &amp;gt; es que está diseñado especialmente para Vala, y integra perfectamente en las cadenas de herramientas ya existentes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Supongo me toca a mi ser el propietario del producto también. De veras, no me importa cómo sera llamado - Valadate es suficiente bueno tal como cualquiera, pero estoy abierto a sugerencias. Si hay suficientes ideas siempre podemos tener una encuesta.&lt;/p&gt;
&lt;p&gt;El siguiente paso será la recopilación de requisitos, lo que ya tengo algunas ideas, pero me gustaría saber lo que los usuarios potenciales piensan. Por eso he armado una pizarra Trello y si deseas sugerir una función o comentar sobre una que ya existe, &lt;a href="http://bit.ly/1ZSrRA6"&gt;haz clik aquí&lt;/a&gt; y hazte oír. Si eso no es su medio preferido, me puedes pingear en &lt;a href="http://twitter.com/chebizarro"&gt;Twitter&lt;/a&gt; o en el canal de IRC de Vala (irc.gimp.org #vala), apodo: &lt;code&gt;bizarro&lt;/code&gt;. Una herramienta como esta va a vivir o morir debido a su aptitud para el uso, así que no te callas por favor!&lt;/p&gt;
&lt;p&gt;Ya está - en el próximo post voy a resumir los requisitos que habría recopilado y poner en la mesa las opciones para la arquitectura del sistema además de elaborar un calendario provisional para la primera versión. Gracias por escuchar y no olvides de unirse a la conversación si tienes algo que decir.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Código Abierto"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry><entry><title>Gherkin for Vala</title><link href="http://chrisdaley.biz/es/gherkin-for-vala-en.html" rel="alternate"></link><updated>2016-01-04T20:50:00-08:00</updated><author><name>Chris Daley</name></author><id>tag:chrisdaley.biz,2016-01-04:es/gherkin-for-vala-en.html</id><summary type="html">&lt;p&gt;I've had some spare time recently to work on some pet projects and get them into a decent enough shape that they could be subjected to the withering gaze of the Panopticon. One in particular is a port of the Gherkin language to Vala. So what is Gherkin exactly and why should you care?&lt;/p&gt;
&lt;p&gt;From the &lt;a href="https://github.com/cucumber/cucumber/wiki/Gherkin"&gt;Gherkin wiki&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gherkin is the language that &lt;a href="https://cucumber.io/"&gt;Cucumber&lt;/a&gt; understands. It is a Business Readable, Domain Specific Language that lets you describe software’s behaviour without detailing how that behaviour is implemented.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Gherkin is available for a host of languages and is tightly integrated into JUnit for example. Its syntax is pretty straightforward and designed to be intelligible by non-technical people:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  Feature: Some terse yet descriptive text of what is desired
  Textual description of the business value of this feature
  Business rules that govern the scope of the feature
   Any additional information that will make the feature easier to understand

   Scenario: Some determinable business situation
     Given some precondition
       And some other precondition
      When some action by the actor
       And some other action
       And yet another action
      Then some testable outcome is achieved
       And something else we can check happens too

   Scenario: A different situation
       ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The Gherkin parser for Vala, which you can get &lt;a href="https://github.com/chebizarro/gherkin-vala"&gt;here&lt;/a&gt; reads in Feature files and builds a tree of elements that can then either be manipulated directly or output as JSON.&lt;/p&gt;
&lt;p&gt;The parser by itself is not tremendously useful, but is one of the building blocks for a comprehensive testing framework for Vala and by extension, GObject that I am presently scoping. If this is something you're interested in, and I assume it is since you've read this far, then I'd encourage you to join the conversation.&lt;/p&gt;</summary><category term="Vala"></category><category term="Open Source"></category><category term="Programming"></category><category term="TDD"></category><category term="BDD"></category></entry></feed>